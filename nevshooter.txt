;---------------------------------------------------------------------------------
; NevShooter copyright Michael Neve 2012
; No, it has nothing to do with shooting me.
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; A note on register usage:
;
;   VF = reserved for carry/collision. Do not use.
;   VE = Scrollback counter. Loops continuously from 0 to 15.
;   VD = Data index. Increments each time VE rolls around.
;---------------------------------------------------------------------------------

  MEGAON							; Megachip8 mode

  CCOL 1 							; Always use col index 1 for collisions		

  LDHI I, dPalette					; Load a palette
  LDPAL 6

lInitialise:

lStartFrame:
  
  CLS

  ; draw BG
;  LDHI I, dBackground
;  LD V0, 0 
;  SPRW 256
;  SPRH 192
;  DRW V0, V0, 1

  ; Load game info. It has the game state (aka number of lives).
  LDHI I, dGameInfo
  LD VC, [I]

  ; if (game.lives == E_GAME_LIVES_0_TITLE) 
  ; do title screen logic
  ; else do game screen logic

  SE VA, E_GAME_LIVES_0_TITLE
  JP lGameScreen

lTitleScreen:

  CALL fDoTitleScreen
  JP lEndFrame

lGameScreen:

  CALL fDoGamePlay

lEndFrame:

  ; update scrollback counter
  ADD VE, 1
  SE VE, 16
  JP lStartFrame
  LD VE, 0

  ; update data scroller
  SE VD, 255
  ADD VD, 1  
  JP lStartFrame

  EXIT

;---------------------------------------------------------------------------------
; fResetAll
;---------------------------------------------------------------------------------
fResetAll

  ; reset laser
  LDHI I, dLaserInfoReset
  LD VC, [I]
  LDHI I, dLaserInfo
  LD [I], VC
 
  ; reset player last, so it remains in registers after reset
  LDHI I, dPlayerInfoReset
  LD VC, [I]
  LDHI I, dPlayerInfo
  LD [I], VC

  ; reset data scroller
  LD VD, 0

  ; reset scrollback counter
  LD VE, 0

  RET

;---------------------------------------------------------------------------------
; fDoTitleScreen
;---------------------------------------------------------------------------------
fDoTitleScreen

  ; draw title
  ; For now, just draw a placeholder
  ; but this could be the same as the background
  SPRW GAME_TITLE_SCREEN_WIDTH
  SPRH GAME_TITLE_SCREEN_HEIGHT
  LDHI I, dBoomSprite
  LD V0, 0
  DRW V0, V0, 1

  ; load game data (contains score, hi-score and KEY_START)  
  ; Already loaded from main function! Bonus!
  LDHI I, dGameInfo
  LD VC, [I]

  ; TODO - draw hi-score

  ; if KEY_START pressed, start game
  SKP V9 							; V9 = game.const KEY_START
  RET

  ; reset game info
  LD VA, E_GAME_LIVES_3				; game.lives = E_GAME_LIVES_3
  LD VB, 0							; game.score = 0
  ; now save game info, minus hi-score
  LD [I], VB

  ; reset everything else
  CALL fResetAll					

  RET

;---------------------------------------------------------------------------------
;
;---------------------------------------------------------------------------------
fDoGamePlay:

  CALL fDrawCollisionWalls

  CALL fDoUpdatePlayer
  CALL fDoUpdateLaser
  
  RET
  
;---------------------------------------------------------------------------------
;
;---------------------------------------------------------------------------------
fDoUpdatePlayer:

  ; load player info
  LDHI I, dPlayerInfo
  LD VC, [I]
  									; V8 = player.nextsprite
		  							; V9 = player.timer
  									; VA = player.xpos
									; VB = player.ypos
									; VC = player.state
  ; set up switch
  LDHI I, dPlayerUpdateSwitchLookup
  ADD I, VC
  LD V1, [I]
  LD I, lPlayerUpdateSwitchStart
  LD [I], V1

  ; draw player
  LD V0, V8								; use player.nextsprite for drawing player
  CALL fDrawPlayer

lPlayerUpdateSwitchStart:
  JP lPlayerUpdateSwitchStart

lPlayerUpdateCaseReviving:
  LDHI I, dPlayerRevivingConstants
  LD V7, [I]
									; V5 = player.const PLAYER_REVIVING_SPEED_X
									; V6 = player.const PLAYER_REVIVING_TIMER_INC
									; V7 = player.const PLAYER_REVIVING_TIMER_MAX
  LD V8, VE
  ADD V8, E_PLAYER_SPRITE_REVIVING_0								; player.nextsprite = E_PLAYER_SPRITE_REVIVING_0 + scrollback									 
  ADD VA, V5						; player.xpos += player.const PLAYER_REVIVING_SPEED_X
  ADD V9, V6							; player.timer += player.const PLAYER_REVIVING_TIMER_INC
  SUB V7, V9	 						; test if player.timer <= player.const PLAYER_REVIVING_TIMER_MAX
  SNE VF, 0							; if no, set player.state = alive
  LD VC, E_PLAYER_STATE_ALIVE		; player.state = E_PLAYER_STATE_ALIVE
  JP lPlayerUpdateSwitchEnd

lPlayerUpdateCaseAlive:
  SNE VF, 1							; player collided. Must have been a bullet.
  JP lPlayerUpdateCaseHitBullet
  
  LDHI I, dPlayerAliveConstants
  LD V8, VE							; player.nextsprite = scrollback counter
  LD V7, [I]
  									; V0 = player.const PLAYER_ALIVE_XPOS_MIN
  									; V1 = player.const PLAYER_ALIVE_XPOS_MAX
  									; V2 = player.const PLAYER_ALIVE_SPEED_X
  									; V3 = player.const PLAYER_ALIVE_SPEED_Y
  									; V4 = player.const KEY_RIGHT 
  									; V5 = player.const KEY_LEFT
  									; V6 = player.const KEY_DOWN
  									; V7 = player.const KEY_UP
  SKP V4							; test KEY_RIGHT pressed
  JP lPlayerUpdateCaseAliveTestKeyLeft
  SUB V1, VA						; test player.xpos <= player.const PLAYER_ALIVE_XPOS_MAX
  SNE VF, 1						; if no, skip to KEY_LEFT test
  JP lPlayerUpdateCaseAliveTestKeyLeft
  RND V8, 3
  ADD V8, E_PLAYER_SPRITE_MOVE_RIGHT_0 		; player.nextsprite = E_PLAYER_SPRITE_MOVE_RIGHT + rnd(0-3) 
  ADD VA, V2						; player.xpos += PLAYER_ALIVE_SPEED_X 
lPlayerUpdateCaseAliveTestKeyLeft:
  SKP V5							; test KEY_LEFT pressed
  JP lPlayerUpdateCaseAliveTestKeyDown
  SUB V0, VA						; test player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN
  SE VF, 1						; if yes, skip to KEY_DOWN test
  JP lPlayerUpdateCaseAliveTestKeyDown
  RND V8, 3
  ADD V8, E_PLAYER_SPRITE_MOVE_LEFT_0		; player.nextsprite = E_PLAYER_SPRITE_MOVE_LEFT	+ rnd(0-3)
  SUB VA, V2						; player.xpos -= PLAYER_SPEED_X
lPlayerUpdateCaseAliveTestKeyDown:
  SKP V6
  JP lPlayerUpdateCaseAliveTestKeyUp
  LD V8, E_PLAYER_SPRITE_MOVE_DOWN		; player.nextsprite = E_PLAYER_SPRITE_MOVE_DOWN
  ADD VB, V3						; player.ypos += PLAYER_SPEED_Y
lPlayerUpdateCaseAliveTestKeyUp:
  SKP V7
  JP lPlayerUpdateSwitchEnd		
  LD V8, E_PLAYER_SPRITE_MOVE_UP	; player.nextsprite = E_PLAYER_SPRITE_MOVE_UP
  SUB VB, V3						; player.ypos -= PLAYER_SPEED_Y
  JP lPlayerUpdateSwitchEnd
  
lPlayerUpdateCaseHitWall:
lPlayerUpdateCaseHitEnemy:
lPlayerUpdateCaseHitBullet:
  LD V9, 0							; player.timer = 0
  LD VC, E_PLAYER_STATE_DYING		; player.state = E_PLAYER_STATE_DYING
  ; fall through

lPlayerUpdateCaseDying:
  LDHI I, dPlayerDyingConstants
  LD V7, [I]
									; V4 = player.const PLAYER_DYING_XPOS_MIN
									; V5 = player.const PLAYER_DYING_SPEED_X
  									; V6 = player.const PLAYER_DYING_TIMER_INC
									; V7 = player.const PLAYER_DYING_TIMER_MAX

  ADD V9, V6							; player.timer += player.const PLAYER_DYING_TIMER_INC
  SUB V7, V9						; test player.timer <= player.const PLAYER_DYING_TIMER_MAX
  SE VF, 1						; if no, skip to dying reset 
  JP lPlayerUpdateCaseDyingReset
  SUB V4, VA						; test player.xpos <= player.const PLAYER_DYING_XPOS_MIN
  SNE VF, 1						; if yes, skip to dying reset
  JP lPlayerUpdateCaseDyingReset
  SUB VA, V6						; player.xpos -= player.const PLAYER_DYING_XPOS_MIN
  LD V8, VE	
  ADD V8, E_PLAYER_SPRITE_DYING_0	; player.nextsprite = E_PLAYER_SPRITE_DYING + scrollback
  JP lPlayerUpdateSwitchEnd  
lPlayerUpdateCaseDyingReset:
  CALL fResetAll
  LD I, dGameInfo + 10				; load game.lives only
  LD V0, [I]
  ADD V0, 255 						; game.lives--
  LD [I], V0
  RET

lPlayerUpdateSwitchEnd:

  ; save all player info
  LDHI I, dPlayerInfo
  LD [I], VC

  RET

;---------------------------------------------------------------------------------
;
;---------------------------------------------------------------------------------
fDoUpdateLaser:

  ; load laser info
  LDHI I, dLaserInfo
  LD VC, [I]
		  							; V9 = laser.timer
  									; VA = laser.xpos
									; VB = laser.ypos
									; VC = laser.state
  ; set up switch
  LDHI I, dLaserUpdateSwitchLookup
  ADD I, VC				
  LD V1, [I]
  LD I, lLaserUpdateSwitchStart
  LD [I], V1

lLaserUpdateSwitchStart:
  JP lLaserUpdateSwitchStart

lLaserUpdateCaseDead:
  LDHI I, dLaserDeadConstants
  LD V8, [I]
									; V7 = laser.const LASER_DEAD_OFFSET_X  
									; V8 = laser.const KEY_FIRE
  LDHI I, dPlayerInfo + 10
  LD V2, [I]						
									; V0 = player.xpos
									; V1 = player.ypos
									; V2 = player.state
  SE V2, E_PLAYER_STATE_ALIVE		; cannot fire if player is not alive
  JP lLaserUpdateSwitchEnd			
  SKP V8							; test KEY_FIRE pressed
  JP lLaserUpdateSwitchEnd
  LD VA, V0
  ADD VA, V7						; laser.xpos = player.xpos + LASER_DEAD_OFFSET_X
  LD VB, V1							; laser.ypos = player.ypos
  LD VC, E_LASER_STATE_ALIVE		; laser.state = E_LASER_STATE_ALIVE
  JP lLaserUpdateSwitchEnd
  
lLaserUpdateCaseAlive:
  LDHI I, dLaserAliveConstants
  LD V8, [I]
									; V7 = laser.const LASER_ALIVE_XPOS_MAX
									; V8 = laser.const LASER_ALIVE_SPEED
  LD V9, VE						; laser.timer = scrollback
  CALL fDrawLaser

  SUB V7, VA						; test laser.xpos >= laser.const LASER_ALIVE_XPOS_MAX
  SE VF, 1
  JP lLaserUpdateCaseAliveOffscreen
  ADD VA, V8
  JP lLaserUpdateSwitchEnd
lLaserUpdateCaseAliveOffscreen:
  LD VC, E_LASER_STATE_DEAD				; laser.state = E_LASER_STATE_DEAD
  JP lLaserUpdateSwitchEnd

lLaserUpdateCaseHitWall:
lLaserUpdateCaseHitEnemy:
  LD V9, 0							; laser.timer = 0
  LD VC, E_PLAYER_STATE_DYING		; laser.state = E_LASER_STATE_DYING
  ; fall through

lLaserUpdateCaseDying:
  LDHI I, dLaserDyingConstants
  LD V8, [I]
						; V8 = laser.const LASER_DYING_TIMER_MAX
  ADD V9, 1							; laser.timer++
  CALL fDrawLaser
  SNE V9, V8						; test laser.timer == laser.const LASER_DYING_TIMER_MAX
  JP lLaserUpdateSwitchEnd
  LD VC, E_LASER_STATE_DEAD			; laser.state = E_LASER_STATE_DEAD

lLaserUpdateSwitchEnd:

  ; save all laser info
  LDHI I, dLaserInfo
  LD [I], VC

  RET

;---------------------------------------------------------------------------------
; fDrawPlayer
; Draws player sprite index V0 at position [VA, VB]
;---------------------------------------------------------------------------------
fDrawPlayer:
  
  ; player info must be loaded before fDrawPlayer is called!
  									; V0 = player sprite
  									; VA = player x-position
  									; VB = player y-position
  ; convert V0 into a sprite address
  SHL V0
  SHL V0							; V0 *= 4 
  LDHI I, dPlayerSpriteLookup
  ADD I, V0
  LD V3, [I]
  LD I, lDrawPlayerOverwrite		
  LD [I], V3		
lDrawPlayerOverwrite:
  LDHI I, lDrawPlayerOverwrite  

  ; draw player.sprite
  SPRW PLAYER_WIDTH
  SPRH PLAYER_HEIGHT
  DRW VA, VB, 1		

  RET

;---------------------------------------------------------------------------------
; fDrawLaser
; Draws laser sprite index V0 at position [VA, VB]
;---------------------------------------------------------------------------------
fDrawLaser:
  
  ; laser info must be loaded before fDrawLaser is called!
  									; V0 = laser sprite
  									; VA = laser x-position
  									; VB = laser y-position
  ; convert V9 into a sprite address
  SHL V0
  SHL V0							; V0 *= 4 
  LDHI I, dLaserSpriteLookup
  ADD I, V0
  LD V3, [I]
  LD I, lDrawLaserOverwrite		
  LD [I], V3		
lDrawLaserOverwrite:
  LDHI I, lDrawLaserOverwrite  

  ; draw laser.sprite
  SPRW LASER_WIDTH
  SPRH LASER_HEIGHT
  DRW VA, VB, 1		

  RET

;---------------------------------------------------------------------------------
; fDrawCollisionWalls
; Draws the upper and lower boundary collision walls.
;---------------------------------------------------------------------------------
fDrawCollisionWalls:
  SPRW 16
  SPRH 16
  
;  LD V4, VD						; V4 = data scroller (VD)
  LD V4, 0
  LD V5, V4							; V5 = V4 + 15. Data scroller end
  ADD V5, 15				
  LD V6, 16							; V6 = Wall tile xpos draw position. Starts at 16.
  SUB V6, VE						; V6 -= scrollback counter
  LD V7, 16							; V7 = Wall tile ypos draw position. Always 16.

lDrawCollisionWallsLoop:

  ; get collision wall sprite index from collision data map
  LDHI I, dTileMap  
  ADD I, V4							; add tile data offset
  LD V0, [I]
 
  ; convert index into lookup address
  SHL V0
  SHL V0
  LDHI I, dCollisionLookup
  ADD I, V0
  LD V3, [I]
  LD I, lDrawCollisionWallsOverwrite
  LD [I], V3
lDrawCollisionWallsOverwrite:
  LDHI I, lDrawCollisionWallsOverwrite

  ; draw collision wall sprite
  DRW V6, V7, 1
 
  ADD V4, 1
  ADD V6, 16
  SE V4, V5
  JP lDrawCollisionWallsLoop

  RET

;---------------------------------------------------------------------------------
; GAME INFO
;---------------------------------------------------------------------------------
INCLUDE 'gameinfo.inc'

;---------------------------------------------------------------------------------
; PLAYER INFO
;---------------------------------------------------------------------------------
INCLUDE 'playerinfo.inc'

;---------------------------------------------------------------------------------
; LASER INFO
;---------------------------------------------------------------------------------
INCLUDE 'laserinfo.inc'

;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------

dTileMap:
  DB 0,1,2,3,4,0,4,3,2,1,0,3,1,2,4,0 

dCollisionLookup:
  LDHI I, dCollisionFull
  LDHI I, dCollisionFloorUp
  LDHI I, dCollisionFloorDown
  LDHI I, dCollisionRoofDown
  LDHI I, dCollisionRoofUp

dCollisionFull:
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1

dCollisionFloorUp:
  DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
  DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
 
dCollisionFloorDown:
  DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1

dCollisionRoofDown:
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
  DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1

dCollisionRoofUp:
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0
  DB 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DB 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

dBoomSprite:
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
  DB 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4

dPalette:
  DB #FF, #FF, #55, #FF    ; 1 = collision index. PINK
  DB #FF, #FF, #FF, #FF    ; 2 = black
  DB #FF, #FF, #FF, #FF    ; 3 = white
  DB #FF, #FF, #00, #00    ; 4 = red
  DB #FF, #00, #FF, #00    ; 5 = green
  DB #FF, #00, #00, #FF    ; 6 = blue

