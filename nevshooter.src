;---------------------------------------------------------------------------------
; NevShooter copyright Michael Neve 2012
; No, it has nothing to do with shooting me.
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; A note on register usage, for in-game and boss states:
;
;   VF = Reserved for carry/collision. Do not use.
; 
;   Gameplay state:
;   VE = Global anim counter. Loops continuously from 0 to GAME_GLOBALANIM_MAX, step GAME_GLOBALANIM_INC. (global.anim)
;   VD = Data index. Increments by GAME_GLOBALDATA_INC each time VE rolls around, up to GAME_GLOBALDATA_MAX. (global.data)
;
;   VD and VE may have different uses in title/gameplay/boss/game-over states
;---------------------------------------------------------------------------------

  MEGAON							; Megachip8 mode

  LDHI I, data_palette						; Load a palette
  LDPAL PALETTE_SIZE

lbl_main_frame_loop_start:
  
  CLS

  ; load game info
  ; It has the game state (aka number of lives).
  LDHI I, data_game_livesinfo-0
  LD V0, [I]
								; V0 = game.lives

  ; if (game.lives == E_GAME_LIVES_START_SCREEN)
  ; then do title screen
  ; else if (game.lives == E_GAME_LIVES_GAME_OVER)
  ; then do game-over screen
  ; else if (game.lives == E_GAME_LIVES_X)
  ; then do gameplay
  ; else if (game.lives == E_GAME_LIVES_X_BOSS)
  ; then do boss
  ; else if (game.lives == E_GAME_LIVES_X_WIN)
  ; then do win screen

  LDHI I, data_game_main_frame_lives_switch_lookup
  ADD I, V0
  LD V1, [I]
  LD I, lbl_main_frame_lives_switch_start
  LD [I], V1

lbl_main_frame_lives_switch_start:
  JP lbl_main_frame_lives_switch_start

lbl_main_frame_lives_case_start_screen:

  CALL func_DoTitleScreen

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1:
lbl_main_frame_lives_case_lives_2:
lbl_main_frame_lives_case_lives_3:

  CALL func_DoBossplay

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1_boss:
lbl_main_frame_lives_case_lives_2_boss:
lbl_main_frame_lives_case_lives_3_boss:

  CALL func_DoBossplay

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1_win:
lbl_main_frame_lives_case_lives_2_win:
lbl_main_frame_lives_case_lives_3_win:
lbl_main_frame_lives_case_game_over:

  CALL func_DoGameOverScreen

  JP lbl_main_frame_lives_switch_end

lbl_main_frame_lives_case_null:

  ; empty

lbl_main_frame_lives_switch_end:

  ; loop to start
  JP lbl_main_frame_loop_start

  EXIT





;---------------------------------------------------------------------------------
; func_DoTitleScreen
;---------------------------------------------------------------------------------
func_DoTitleScreen:

  ; draw title screen sprite
  SPRW TITLE_SCREEN_WIDTH
  SPRH TITLE_SCREEN_HEIGHT
  LDHI I, data_sprite_title_screen
  LD V0, 0
  DRW V0, V0, 1

  ; increment a title screen timer				; VD = gametitle.timer
  SE VD, GAMETITLE_TIMER_MAX
  ADD VD, GAMETITLE_TIMER_INC

  ; load game data 
  LDHI I, data_game_hiscoreinfo-5
  LD VC, [I]
								; V5 = game.hi-score 100s
								; V6 = game.hi-score 10s
								; V7 = game.hi-score 1s
								; V8 = game.hi-score
								; V9 = game.const GAME_HISCORE_Y_POS
								; VA = game.const GAME_HISCORE_100S_X_POS
								; VB = game.const GAME_HISCORE_10S_X_POS
								; VC = game.const GAME_HISCORE_1S_X_POS


  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; draw hi-score 100s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_game_start_screen_ptr1
  LD [I], V3
lbl_game_start_screen_ptr1:
  LDHI I, lbl_game_start_screen_ptr1
  DRW VA, V9, 1

  ; draw hi-score 10s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_game_start_screen_ptr2
  LD [I], V3
lbl_game_start_screen_ptr2:
  LDHI I, lbl_game_start_screen_ptr2
  DRW VB, V9, 1

  ; draw hi-score 1s
  LDHI I, data_number_lookup
  ADD I, V7
  LD V3, [I]
  LD I, lbl_game_start_screen_ptr3
  LD [I], V3
lbl_game_start_screen_ptr3:
  LDHI I, lbl_game_start_screen_ptr3
  DRW VC, V9, 1

  ; if gametitle.timer < GAMETITLE_TIMER_ALLOW_CONTINUE
  ; then return
  LD V0, GAMETITLE_TIMER_ALLOW_CONTINUE
  SUB V0, VD
  SE VF, 0
  RET

  ; if (KEY_START != pressed)
  ; then return
  LD V0, KEY_START
  SKP V0				
  RET

  ; Begin transition into gameplay state
  ; reset lives
  LDHI I, data_game_livesinfo-0
  LD V0, E_GAME_LIVES_3						; game.lives = E_GAME_LIVES_3
  LD [I], V0

  ; reset score
  LDHI I, data_game_scoreinfo-0
  LD V0, 0							; game.score 100s = 0
  LD V1, 0							; game.score 10s = 0
  LD V2, 0							; game.score 1s = 0
  LD V3, 0							; game.score = 0
  LD [I], V3

  ; reset everything else
  CALL func_ResetGameplay

  ; load gameplay threats
  ; CALL func_LoadGameplayThreats					

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_ResetGameplay
;---------------------------------------------------------------------------------
func_ResetGameplay:

  ; reset bullet slots
  ; TODO

  ; reset enemy slots
  ; TODO

  ; reset laser
  LDHI I, data_laser_reset
  LD V4, [I]
  LDHI I, data_laser_info
  LD [I], V4
 
  ; reset player
  LDHI I, data_player_reset
  LD V4, [I]
  LDHI I, data_player_info
  LD [I], V4

  ; reset global.data
  LD VD, 0

  ; reset global.anim
  LD VE, 0 
  
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoGameplay
;---------------------------------------------------------------------------------
func_DoGameplay:

;  CALL func_DoEnemiesVsLaser
;  CALL func_DrawBackgroundAndParallax
;  CALL func_DrawCollisionWalls
;  CALL func_DoLaserVsWalls
;  CALL func_DoPlayerVsWalls
;  CALL func_DoEnemiesVsPlayerOrWalls
;  CALL func_DoPlayerVsEnemies
;  CALL func_DoUpdateBullets
;  CALL func_DoPlayerVsBullets
;  CALL func_DrawRealWalls
;  CALL func_DoUpdateLaser
;  CALL func_DoUpdateEnemies
  CALL func_DoUpdatePlayer

  ; Do special flow control for gameplay state
  ; player.state is already loaded in VC from func_DoUpdatePlayer

lbl_do_gameplay_test_for_player_dead:

  SE VC, E_PLAYER_STATE_DEAD
  JP lbl_do_gameplay_test_for_player_success

  CALL func_ResetGameplay
  
  ; decrement game.lives
  LD I, data_game_livesinfo-0				 
  LD V4, [I]
  AND V0, V1							; game.lives &= GAME_LIVES_GAMEPLAY_MASK
  ADD V0, GAME_LIVES_DEC 					; game.lives--
  LD [I], V0

  JP lbl_do_gameplay_test_end

lbl_do_gameplay_test_for_player_success:

  SE VC, E_PLAYER_STATE_SUCCESS
  JP lbl_do_gameplay_test_end

; CALL func_ResetBossplay
;
; ; update lives
;  LD I, data_game_livesinfo-0				 
;  LD V4, [I]
;  ADD V0, GAME_LIVES_BOSS_SHIFT				; game.lives += GAME_LIVES_BOSS_SHIFT
;  LD [I], V0

lbl_do_gameplay_test_end:
  
  CALL func_DrawBorder

  ; increment anim counter
  ADD VE, GAMEPLAY_GLOBALANIM_INC				; global.anim++

  ; if (global.anim != 64)
  ; then early exit 
  SE VE, GAMEPLAY_GLOBALANIM_MAX
  RET
  
  LD VE, 0							; global.anim = 0
  
  ; global.data controls the wallinfo and all gameplay threats
  ; During normal gameplay, it doesn't want to pass ~240, because the last screen should be for player outro 
  ; if (global.data == GAMEPLAY_GLOBALDATA_MAX)
  ; then early exit
  SNE VD, GAMEPLAY_GLOBALDATA_MAX
  RET

  ADD VD, GAMEPLAY_GLOBALDATA_INC				; global.data++

  ; load any new enemies or bullets
;  CALL func_LoadGameplayThreats

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_ResetBossplay
;---------------------------------------------------------------------------------
func_ResetBossplay:

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoBossplay
;---------------------------------------------------------------------------------
func_DoBossplay:

  ; draw collision walls in orange
  LDHI I, data_sprite_boss_background_col
  SPRW BOSS_BACKGROUND_WIDTH
  SPRH BOSS_BACKGROUND_HEIGHT

  LD V0, 0

  DRW V0, V0, 1

  ; draw player collision in orange, test for collision against walls
  CALL func_DoPlayerVsWalls  
 
  ; draw laser collision in purple, test for collision against walls
  CALL func_DoLaserVsWalls

  ; laser is still in memory from func_DoLaserVsWalls
  ; draw boss collision in white, test against laser
  ; CALL func_DoBossVsLaser

  ; draw enemies collision in white, test for collision against walls, player or laser
  ; CALL func_DoEnemiesVsEverything

  ; draw player collision in orange, test for collision against enemies, which will include boss
  ; CALL func_DoPlayerVsEnemies





  LDHI I, data_boss_info-8
  LD VC, [I]
								; 
  SPRW BOSS_WIDTH
  SPRH BOSS_HEIGHT
  LD V4, E_BOSS_SPRITE_COL_WHITE
  CALL func_DrawBossEye





  ; draw walls, background, etc
  LDHI I, data_sprite_boss_background
  SPRW BOSS_BACKGROUND_WIDTH
  SPRH BOSS_BACKGROUND_HEIGHT
  LD V0, 0
  DRW V0, V0, 1
 
  CALL func_DoUpdateLaser
  CALL func_DoUpdateBoss

  CALL func_DoUpdatePlayer


;  CALL func_DoEnemiesVsPlayerOrWalls
;  CALL func_DoPlayerVsEnemies
;  CALL func_DoPlayerVsBoss
;
; ;  CALL func_DoUpdateBullets
; ;  CALL func_DoPlayerVsBullets
;
; draw boss screen
;  CALL func_DoUpdateEnemies

  CALL func_DrawBorder

  ; increment anim counter
  ADD VE, GAMEPLAY_GLOBALANIM_INC				; global.anim++

  ; if (global.anim != 64)
  ; then early exit 
  SE VE, GAMEPLAY_GLOBALANIM_MAX
  RET
 
  LD VE, 0							; global.anim = 0
  
;  ; global.data controls the boss bullets and missiles
;  ADD VD, GAMEBOSS_GLOBALDATA_INC				; global.data++
;
;  SE VD, GAMEBOSS_GLOBALDATA_MAX
;  RET
;
;
;  ; load any new enemies or bullets
;  CALL func_LoadBossThreats

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoGameOverScreen
;---------------------------------------------------------------------------------
func_DoGameOverScreen:

  LDHI I, data_sprite_game_over_screen
  
  LD VE, 0							; VE = cumulative totalscore
  
  ; Draw game over screen sprite
  SPRW GAME_OVER_SCREEN_WIDTH
  SPRH GAME_OVER_SCREEN_HEIGHT
  DRW VE, VE, 1

  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; increment a game over screen timer				; VD = game.gameovertimer
  SE VD, GAMEOVER_SCREEN_TIMER_MAX
  ADD VD, GAMEOVER_SCREEN_TIMER_INC

  LDHI I, data_gameover_screen_enemies_display-8

  LD VC, [I]
								; V8 = game.const GAMEOVER_ENEMIES_Y_POS
 								; V9 = game.const GAMEOVER_ENEMIES_100S_X_POS
								; VA = game.const GAMEOVER_ENEMIES_10S_X_POS
								; VB = game.const GAMEOVER_ENEMIES_1S_X_POS
								; VC = game.const GAMEOVER_TIMER_ENEMIES

  ; if game.gameovertimer < GAMEOVER_TIMER_ENEMIES
  ; then skip to drawing current totalscore
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  ; draw enemies count

  LDHI I, data_game_scoreinfo-4
  LD V7, [I]
								; V4 = game.score 100s
								; V5 = game.score 10s
								; V6 = game.score 1s
								; V7 = game.score  

  LD VE, V7							; totalscore = game.score

  ; draw enemies 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr1
  LD [I], V3
lbl_gameover_enemies_ptr1:
  LDHI I, lbl_gameover_enemies_ptr1
  DRW V9, V8, 1

  ; draw enemies 10s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr2
  LD [I], V3
lbl_gameover_enemies_ptr2:
  LDHI I, lbl_gameover_enemies_ptr2
  DRW VA, V8, 1

  ; draw enemies 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr3
  LD [I], V3
lbl_gameover_enemies_ptr3:
  LDHI I, lbl_gameover_enemies_ptr3
  DRW VB, V8, 1

  ; draw boss and lives counters	

  LDHI I, data_gameover_screen_bosslives-7
  LD VC, [I]
								; V7 = game.const GAMEOVER_LIVES_Y_POS
  								; V8 = game.const GAMEOVER_LIVES_X_POS
 								; V9 = game.const GAMEOVER_BOSS_Y_POS
 								; VA = game.const GAMEOVER_BOSS_X_POS
 								; VB = game.const GAMEOVER_TIMER_LIVES
 								; VC = game.const GAMEOVER_TIMER_BOSS

  ; if game.gameovertimer < GAMEOVER_TIMER_BOSS
  ; then skip to drawing current totalscore
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_game_livesinfo-0
  LD V0, [I]
								; V0 = game.lives

  LDHI I, data_gameover_screen_lives_switch_lookup
  ADD I, V0
  LD V1, [I]
  LD I, lbl_gameover_lives_switch_start
  LD [I], V1

lbl_gameover_lives_switch_start:
  JP lbl_gameover_lives_switch_start

lbl_gameover_lives_case_game_over:

  LDHI I, data_sprite_number_0
  DRW VA, V9, 1
  
  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  DRW V8, V7, 1

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_1_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_0_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_1
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_1_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_2_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_0_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_2
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_1_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_3_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_2_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_3
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_3_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break;

lbl_gameover_lives_case_start_screen:
lbl_gameover_lives_case_lives_1:
lbl_gameover_lives_case_lives_2:
lbl_gameover_lives_case_lives_3:
lbl_gameover_lives_case_lives_1_boss:
lbl_gameover_lives_case_lives_2_boss:
lbl_gameover_lives_case_lives_3_boss:
lbl_gameover_lives_case_null:

  ; empty

lbl_gameover_lives_switch_end:

lbl_gameover_totalscore_ptr1:

  ; draw total score
  LDHI I, data_gameover_screen_score_display-0			
  ; set BCD
  LD B, VE
  
  LDHI I, data_gameover_screen_score_display-5
  LD VC, [I]
								; V5 = reserved for game.resultscore 100s
  								; V6 = reserved for game.resultscore 10s
  								; V7 = reserved for game.resultscore 1s
								; V8 = game.const GAMEOVER_SCORE_Y_POS
  								; V9 = game.const GAMEOVER_SCORE_100S_X_POS
  								; VA = game.const GAMEOVER_SCORE_10S_X_POS
  								; VB = game.const GAMEOVER_SCORE_1S_X_POS
  								; VC = game.const GAMEOVER_TIMER_TOTALSCORE

  SHL V5
  SHL V5
  SHL V6
  SHL V6
  SHL V7
  SHL V7

  LD [I], V7

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr2
  LD [I], V3
lbl_gameover_totalscore_ptr2:
  LDHI I, lbl_gameover_totalscore_ptr2
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr3
  LD [I], V3
lbl_gameover_totalscore_ptr3:
  LDHI I, lbl_gameover_totalscore_ptr3
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V7
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr4
  LD [I], V3
lbl_gameover_totalscore_ptr4:
  LDHI I, lbl_gameover_totalscore_ptr4
  DRW VB, V8, 1

  ; draw hi-score
  LDHI I, data_gameover_screen_hiscore_display-8
  LD VC, [I]
								; V8 = game.const GAMEOVER_HISCORE_Y_POS
  								; V9 = game.const GAMEOVER_HISCORE_100S_X_POS
							  	; VA = game.const GAMEOVER_HISCORE_10S_X_POS
								; VB = game.const GAMEOVER_HISCORE_1S_X_POS
								; VC = game.const GAMEOVER_TIMER_HISCORE

  LDHI I, data_game_hiscoreinfo-4
  LD V7, [I]
								; V4 = current game.hi-score 100s
								; V5 = current game.hi-score 10s
								; V6 = current game.hi-score 1s
								; V7 = current game.hi-score
  
  ; if game.gameovertimer < game.const GAMEOVER_TIMER_HISCORE
  ; then skip to drawing current hi-score
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_hiscore_ptr1

  ; if totalscore < hi-score
  ; then jump to pressed start test
  SUB V7, VE
  SE VF, 0
  JP lbl_gameover_press_start

  LD V7, VE							; new game.hi-score = totalscore

  LDHI I, data_gameover_screen_score_display-4
  LD V6, [I]
								; V4 = new game.hi-score 100s = game.resultscore 100s
								; V5 = new game.hi-score 10s = game.resultscore 10s
								; V6 = new game.hi-score 1s = game.resultscore 1s

  ; save new hi-score
  LDHI I, data_game_hiscoreinfo-4
  LD [I], V7

lbl_gameover_press_start:

  ; if (KEY_START != pressed)
  ; then return
  LD V0, KEY_START
  SKP V0				
  JP lbl_gameover_hiscore_ptr1

  ; go to title screen
  LDHI I, data_game_livesinfo-0
  LD V0, E_GAME_LIVES_START_SCREEN				; game.lives = E_GAME_LIVES_TITLE_SCREEN
  LD [I], V0
  LD VD, 0
  LD VE, 0

  RET

lbl_gameover_hiscore_ptr1:

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr2
  LD [I], V3
lbl_gameover_hiscore_ptr2:
  LDHI I, lbl_gameover_hiscore_ptr2
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup  
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr3
  LD [I], V3
lbl_gameover_hiscore_ptr3:
  LDHI I, lbl_gameover_hiscore_ptr3
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr4
  LD [I], V3
lbl_gameover_hiscore_ptr4:
  LDHI I, lbl_gameover_hiscore_ptr4
  DRW VB, V8, 1

  RET
;---------------------------------------------------------------------------------








 
















;---------------------------------------------------------------------------------
; func_DoLaserVsWalls
; Test laser collision against walls
;---------------------------------------------------------------------------------
func_DoLaserVsWalls:

  ; collision walls should have already been drawn in orange

  ; load laser
  LDHI I, data_laser_info-8
  LD VC, [I]
								; V8 = laser.timer
								; V9 = laser.xpos
								; VA = laser.ypos
								; VB = laser.state
								; VC = laser.charge

  ; if (laser.state != alive)
  ; then early return
  SE VB, E_LASER_STATE_ALIVE
  RET

  ; set collision test colour to orange, since we drew the walls in orange
  CCOL COL_ORANGE

  ; draw laser in purple
  SPRW LASER_WIDTH
  SPRH LASER_HEIGHT
  LD V4, E_LASER_SPRITE_COL_PURPLE
  CALL func_DrawLaser

  ; if laser not collided with walls
  ; then early return
  SE VF, 1
  RET
 
  ; laser collided with a wall
  LD VB, E_LASER_STATE_HIT_WALL					; laser.state = E_LASER_STATE_HIT_WALL

  ; save updated laser state
  LDHI I, data_laser_info-8
  LD [I], VC
  
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoPlayerVsWalls
; Test player against collision walls
;---------------------------------------------------------------------------------
func_DoPlayerVsWalls:

  ; collision walls should have already been drawn in orange 

  ; load player
  LDHI I, data_player_info-8
  LD VC, [I]		
								; V8 = player.nextsprite
								; V9 = player.timer	
								; VA = player.xpos
								; VB = player.ypos
								; VC = player.state

  ; if (player.state != alive)
  ; then return
  SE VC, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to orange
  CCOL COL_ORANGE

  ; draw player, also in orange
  SPRW PLAYER_WIDTH
  SPRH PLAYER_HEIGHT
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against walls
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD VC, E_PLAYER_STATE_HIT_WALL

  ; save player state
  LDHI I, data_player_info-8
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; func_DoPlayerVsEnemies
; Test player against collision enemies
;---------------------------------------------------------------------------------
func_DoPlayerVsEnemies:

  ; collision enemies should have already been drawn in white
  ; This will also test against boss if boss collision has been drawn in white 

  ; load player
  LDHI I, data_player_info-8
  LD VC, [I]		
								; V8 = player.nextsprite
								; V9 = player.timer	
								; VA = player.xpos
								; VB = player.ypos
								; VC = player.state

  ; if (player.state != alive)
  ; then return
  SE VC, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to white
  CCOL COL_WHITE

  ; draw player, in orange
  SPRW PLAYER_WIDTH
  SPRH PLAYER_HEIGHT
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against enemies
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD VC, E_PLAYER_STATE_HIT_ENEMY

  ; save player state
  LDHI I, data_player_info-8
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; func_DoPlayerVsBullets
; Test player against collision bullets
;---------------------------------------------------------------------------------
func_DoPlayerVsBullets:

  ; collision bullets should have already been drawn in purple
  ; this will also test collision against laser, MAKE SURE PLAYER AND LASER NEVER OVERLAP

  ; load player
  LDHI I, data_player_info-8
  LD VC, [I]		
								; V8 = player.nextsprite
								; V9 = player.timer	
								; VA = player.xpos
								; VB = player.ypos
								; VC = player.state

  ; if (player.state != alive)
  ; then return
  SE VC, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to purple
  CCOL COL_PURPLE

  ; draw player, in orange
  SPRW PLAYER_WIDTH
  SPRH PLAYER_HEIGHT
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against bullets
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD VC, E_PLAYER_STATE_HIT_BULLET

  ; save player state
  LDHI I, data_player_info-8
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------











;---------------------------------------------------------------------------------
; func_DoEnemiesVsLaser
;---------------------------------------------------------------------------------
func_DoEnemiesVsLaser:

  ; load laser
  LDHI I, data_laser_info-8
  LD VC, [I]
								; V8 = laser.timer
								; V9 = laser.xpos
								; VA = laser.ypos
								; VB = laser.state
								; VC = laser.charge

  ; if (laser.state != alive)
  ; then exit test
  SE VB, E_LASER_STATE_ALIVE
  RET

  ; draw collision laser
  SPRW LASER_WIDTH
  SPRH LASER_HEIGHT
  LD V4, E_LASER_SPRITE_COL_PURPLE
  CALL func_DrawLaser

  ; Set collision test colour. Collide against purple, since we drew the laser in purple.
  CCOL COL_PURPLE

  ; VA is now our enemy loop counter/indexer			; VA = enemy looper
  LD VA, 0	
  
  ; set enemy sprite params
  SPRW ENEMY_WIDTH
  SPRH ENEMY_HEIGHT

lbl_enemy_vs_laser_loop_start:

  ; load enemy info
  LDHI I, data_enemy_slot_lookup
  ADD I, VA
  LD V3, [I]
  LD I, lbl_enemy_vs_laser_ptr1
  LD [I], V3
  LD I, lbl_enemy_vs_laser_ptr2
  LD [I], V3

lbl_enemy_vs_laser_ptr1:
  LDHI I, lbl_enemy_vs_laser_ptr1
  LD V9, [I]
								; V5 = enemy.health
  								; V6 = enemy.state
  								; V7 = enemy.xpos
								; V8 = enemy.ypos
						 		; V9 = enemy.type

  ; if (enemy.state != alive)
  ; then do next enemy
  SE V6, E_ENEMY_STATE_ALIVE
  JP lbl_enemy_vs_laser_loop_next
  
  ; draw enemy in white
  LD V4, E_ENEMY_SPRITE_COL_WHITE
  CALL func_DrawEnemy
  
  ; if no collision against laser
  ; then go to next enemy
  SE VF, 1
  JP lbl_enemy_vs_laser_loop_next				
  
lbl_enemy_vs_laser_ptr2:
  LDHI I, lbl_enemy_vs_laser_ptr2

  ; logic is something like this:
  ; if (laser.charge == enemy.charge)
  ; then laser=dying, enemy=dying
  ; else if (laser.charge < enemy.health)
  ; then enemy.health -= laser.charge, laser=dying
  ; else laser.charge -= enemy.charge, enemy=dying

  ; if laser.charge != enemy.health
  ; then goto laser.charge < enemy.health test
  SE V5, VC
  JP lbl_enemy_vs_laser_less_than

  ; laser.charge == enemy.health, both are dying
  LD VB, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  LD V6, E_ENEMY_STATE_KILLED_BY_LASER 				; enemy.state = E_ENEMY_STATE_KILLED_BY_LASER
  
  ; save enemy
  LD [I], V9
  
  ; laser has no more charge, end test
  JP lbl_enemy_vs_laser_end
   
lbl_enemy_vs_laser_less_than:
  ; if laser.charge > enemy.health
  ; then goto laser.charge > enemy.health branch
  LD V0, V5
  SUB V0, VC
  SE VF, 1
  JP lbl_enemy_vs_laser_greater_than
  
  ; laser.charge < enemy.health
  LD V6, E_ENEMY_STATE_DAMAGED_BY_LASER 			; enemy.state = E_ENEMY_STATE_DAMAGED_BY_LASER
  SUB V5, VC							; enemy.health -= laser.charge
  LD VB, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  
  ; save enemy
  LD [I], V9
  
  ; laser has no more charge, end test
  JP lbl_enemy_vs_laser_end
  
lbl_enemy_vs_laser_greater_than:

  SUB VC, V5							; laser.charge -= enemy.health
  LD V6, E_ENEMY_STATE_KILLED_BY_LASER 				; enemy.state = E_ENEMY_STATE_KILLED_BY_LASER
  
  ; save enemy
  LD [I], V9
  
  ; laser still has some charge, go to next enemy by falling through

lbl_enemy_vs_laser_loop_next:

  ; if (loop != ENEMY_SLOT_MAX)
  ; then goto start of loop
  ADD VA, ENEMY_SLOT_INC
  SE VA, E_ENEMY_SLOT_MAX
  JP lbl_enemy_vs_laser_loop_start

lbl_enemy_vs_laser_end:

  ; save updated laser info
  LDHI I, data_laser_info-8
  LD VA, [I]
  LD [I], VC  

  RET 
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoEnemiesVsPlayerOrWalls
; Test enemies against collision walls
;---------------------------------------------------------------------------------
func_DoEnemiesVsPlayerOrWalls:

  ; collision walls should have already been drawn in orange
  ; collision player should have also been drawn in orange  

  ; VA is now our enemy loop counter/indexer			; VA = enemy looper
  LD VA, 0	

  ; set enemy sprite params
  SPRW ENEMY_WIDTH
  SPRH ENEMY_HEIGHT

lbl_enemy_vs_walls_and_player_loop_start:

   ; load enemy info
  LDHI I, data_enemy_slot_lookup
  ADD I, VA
  LD V3, [I]
  LD I, lbl_enemy_vs_walls_and_player_ptr1
  LD [I], V3
  LD I, lbl_enemy_vs_walls_and_player_ptr2
  LD [I], V3

lbl_enemy_vs_walls_and_player_ptr1:
  LDHI I, lbl_enemy_vs_walls_and_player_ptr1
  LD V9, [I]
								; V5 = enemy.health
  								; V6 = enemy.state
  								; V7 = enemy.xpos
								; V8 = enemy.ypos
						 		; V9 = enemy.type

  ; if (enemy.state != alive)
  ; then do next enemy
  SE V6, E_ENEMY_STATE_ALIVE
  JP lbl_enemy_vs_walls_and_player_loop_next
  
  ; draw enemy in white
  LD V4, E_ENEMY_SPRITE_COL_WHITE
  CALL func_DrawEnemy
  
  ; if no collision against player or walls
  ; then go to next enemy
  SE VF, 1
  JP lbl_enemy_vs_walls_and_player_loop_next				
  
  ; enemy has hit something
  LD V6, E_ENEMY_STATE_HIT_PLAYER_OR_WALL

lbl_enemy_vs_walls_and_player_ptr2:
  LDHI I, lbl_enemy_vs_walls_and_player_ptr2

  ; save enemy
  LD [I], V9

  ; fall through to next enemy

lbl_enemy_vs_walls_and_player_loop_next:

  ; if (loop != ENEMY_SLOT_MAX)
  ; then goto start of loop
  ADD VA, ENEMY_SLOT_INC
  SE VA, E_ENEMY_SLOT_MAX
  JP lbl_enemy_vs_walls_and_player_loop_start

lbl_enemy_vs_walls_and_player_loop_end:

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateBullets
;---------------------------------------------------------------------------------
func_DoUpdateBullets

  RET
;---------------------------------------------------------------------------------




;---------------------------------------------------------------------------------
; func_DoUpdatePlayer
;---------------------------------------------------------------------------------
func_DoUpdatePlayer:

  ; load player info
  LDHI I, data_player_info-8
  LD VC, [I]
  								; V8 = player.nextsprite
		  						; V9 = player.timer
  								; VA = player.xpos
								; VB = player.ypos
								; VC = player.state

  ; draw player
  SPRW PLAYER_WIDTH
  SPRH PLAYER_HEIGHT
  LD V4, V8							; use player.nextsprite for drawing player
  CALL func_DrawPlayer

  ; set up switch
  LDHI I, data_player_update_state_switch_lookup
  ADD I, VC
  LD V1, [I]
  LD I, lbl_do_update_player_switch_start
  LD [I], V1

lbl_do_update_player_switch_start:
  JP lbl_do_update_player_switch_start

lbl_do_update_player_case_reviving:

  LDHI I, data_player_reviving_constants-6
  LD V8, [I]
								; V6 = player.const PLAYER_REVIVING_SPEED_X
								; V7 = player.const PLAYER_REVIVING_TIMER_MAX
  								; V8 = player.nextstate = E_PLAYER_SPRITE_REVIVING_0

  ; player reviving uses global.anim counter for animation
  ADD V8, VE							; player.nextsprite += global.anim									 
  ADD VA, V6							; player.xpos += player.const PLAYER_REVIVING_SPEED_X

  ADD V9, 1							; player.timer++

  ; if (player.timer == player.const PLAYER_REVIVING_TIMER_MAX)
  ; then set player.state = alive
  SNE V9, V7
  LD VC, E_PLAYER_STATE_ALIVE					; player.state = E_PLAYER_STATE_ALIVE

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_case_alive:

  LDHI I, data_player_alive_constants-0
  LD V8, [I]
								; V0 = player.const PLAYER_ALIVE_XPOS_MIN
								; V1 = player.const PLAYER_ALIVE_XPOS_MAX
								; V2 = player.const PLAYER_ALIVE_SPEED_X
								; V3 = player.const PLAYER_ALIVE_SPEED_Y
								; V4 = player.const KEY_RIGHT 
								; V5 = player.const KEY_LEFT
								; V6 = player.const KEY_DOWN
								; V7 = player.const KEY_UP
								; V8 = player.nextsprite = E_PLAYER_STATE_ALIVE_0

  ; player alive uses global.anim counter for animation
  ADD V8, VE							; player.nextsprite += global.anim

  ; if (KEY_RIGHT != pressed)
  ; then jump to key_left test
  SKP V4							; test KEY_RIGHT pressed
  JP lbl_do_update_player_left_key_test

  ; if (player.xpos > player.const PLAYER_ALIVE_XPOS_MAX)
  ; then jump to key_left test
  SUB V1, VA
  SE VF, 1							; VF = 0 if player.xpos > player.const PLAYER_ALIVE_XPOS_MAX
  JP lbl_do_update_player_left_key_test

  ADD VA, V2							; player.xpos += player.const PLAYER_ALIVE_SPEED_X 

lbl_do_update_player_left_key_test:
  ; if (KEY_LEFT != pressed)
  ; then jump to key_down test
  SKP V5							; test KEY_LEFT pressed
  JP lbl_do_update_player_down_key_test

  ; if (player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN)
  ; then jump to key_down test
  SUB V0, VA						
  SNE VF, 1							; VF = 1 if player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN
  JP lbl_do_update_player_down_key_test
  
  SUB VA, V2							; player.xpos -= player.const PLAYER_ALIVE_SPEED_X

lbl_do_update_player_down_key_test:
  ; if (KEY_DOWN != pressed)
  ; then jump to key_up test
  SKP V6
  JP lbl_do_update_player_up_key_test

  ; player moving down uses fixed frame E_PLAYER_SPRITE_MOVE_DOWN
  LD V8, E_PLAYER_SPRITE_MOVE_DOWN				; player.nextsprite = E_PLAYER_SPRITE_MOVE_DOWN
 
  ADD VB, V3							; player.ypos += player.const PLAYER_SPEED_Y

lbl_do_update_player_up_key_test:
  ; if (KEY_UP != pressed)
  ; then jump to switch end
  SKP V7
  JP lbl_do_update_player_switch_end		

  SUB VB, V3							; player.ypos -= PLAYER_SPEED_Y

  JP lbl_do_update_player_switch_end				; break
  
lbl_do_update_player_case_hit_wall:
lbl_do_update_player_case_hit_enemy:
lbl_do_update_player_case_hit_bullet:

  LD V9, 0							; player.timer = 0
 
  LD VC, E_PLAYER_STATE_DYING					; player.state = E_PLAYER_STATE_DYING

  ; fall through to case_dying

lbl_do_update_player_case_dying:

  LDHI I, data_player_dying_constants-5
  LD V8, [I]
								; V5 = player.const PLAYER_DYING_XPOS_MIN
								; V6 = player.const PLAYER_DYING_SPEED_X
								; V7 = player.const PLAYER_DYING_TIMER_MAX
								; V8 = player.nextsprite = E_PLAYER_SPRITE_DYING_0
 
  ; if (player.timer == player.const PLAYER_DYING_TIMER_MAX)
  ; then skip to player has died
  SNE V9, V7
  JP lbl_do_update_player_died_ptr			

  ; if (player.xpos <= player.const PLAYER_DYING_XPOS_MIN)
  ; then skip player has died
  SUB V5, VA			
  SNE VF, 1							; VF = 0 if player.xpos > player.const PLAYER_DYING_XPOS_MIN
  JP lbl_do_update_player_died_ptr				

  ; still dying
  ADD V8, VE							; player.nextsprite += global.anim

  ADD V9, 1							; player.timer++
  
  SUB VA, V6							; player.xpos -= player.const PLAYER_DYING_SPEED_X

  JP lbl_do_update_player_switch_end 				; break

lbl_do_update_player_died_ptr:
  
  ; player has died
  LD VC, E_PLAYER_STATE_DEAD					; player.state = E_PLAYER_STATE_DEAD  

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_case_outro:

  LDHI I, data_player_outro_constants-6
  LD V8, [I]
								; V6 = player.const PLAYER_OUTRO_XPOS_MAX
								; V7 = player.const PLAYER_OUTRO_SPEED_X
								; V8 = player.nextsprite = E_PLAYER_SPRITE_REVIVING_0
 
  ; if (player.xpos > player.const PLAYER_DYING_XPOS_MIN)
  ; then skip to player has succeeded
  SUB V6, VA			
  SNE VF, 0							; VF = 0 if player.xpos > player.const PLAYER_OUTRO_XPOS_MAX
  JP lbl_do_update_player_succeeded_ptr				

  ; still outro-ing
  ADD V8, VE							; player.nextsprite += global.anim
  
  ADD VA, V7							; player.xpos += player.const PLAYER_OUTRO_SPEED_X

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_succeeded_ptr:

  ; player has succeeded!
  LD VC, E_PLAYER_STATE_SUCCESS					; player.state = E_PLAYER_STATE_SUCCESS	
  
  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_case_success:
lbl_do_update_player_case_dead:

  ; empty - do nothing

lbl_do_update_player_switch_end:

  ; save all player info
  LDHI I, data_player_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------




;---------------------------------------------------------------------------------
; func_DoUpdateLaser
;---------------------------------------------------------------------------------
func_DoUpdateLaser:

  ; load laser info
  LDHI I, data_laser_info-8
  LD VC, [I]
		  						; V8 = laser.timer
  								; V9 = laser.xpos
								; VA = laser.ypos
								; VB = laser.state
								; VC = laser.charge
  
  SPRW LASER_WIDTH
  SPRH LASER_HEIGHT

  ; set up switch
  LDHI I, data_laser_update_state_switch_lookup
  ADD I, VB				
  LD V1, [I]
  LD I, lbl_do_update_laser_switch_start
  LD [I], V1

lbl_do_update_laser_switch_start:
  JP lbl_do_update_laser_switch_start

lbl_do_update_laser_case_dead:

  LDHI I, data_laser_dead_constants-5
  LD V7, [I]
								; V5 = laser.const LASER_DEAD_OFFSET_X
								; V6 = laser.const LASER_DEAD_OFFSET_Y  
								; V7 = laser.const KEY_FIRE
  LDHI I, data_player_info-0
  LD V4, [I]						
								; V0 = player.nextsprite
								; V1 = player.timer
								; V2 = player.xpos
								; V3 = player.ypos
								; V4 = player.state
  ; if (player != alive)
  ; then jump to end of switch
  SE V4, E_PLAYER_STATE_ALIVE					; cannot fire if player is not alive
  JP lbl_do_update_laser_switch_end			

  ; if (KEY_FIRE != pressed)
  ; then jump to end of switch
  SKP V7							; test KEY_FIRE pressed
  JP lbl_do_update_laser_switch_end
  
  ; optimisation to be had here - some kind of reset for setting V9, VA, VB, VC from memory

  LD V9, V2
  ADD V9, V5							; laser.xpos = player.xpos + laser.const LASER_DEAD_OFFSET_X

  LD VA, V3
  ADD VA, V6							; laser.ypos = player.ypos + laser.const LASER_DEAD_OFFSET_Y

  LD VB, E_LASER_STATE_ALIVE					; laser.state = E_LASER_STATE_ALIVE

  LD VC, LASER_DEAD_CHARGE					; laser.charge = LASER_DEAD_CHARGE
  
  ; fall through to case_alive
  
lbl_do_update_laser_case_alive:
  
  LDHI I, data_laser_alive_constants-4
  LD V7, [I]
								; V4 = E_LASER_SPRITE_ALIVE_0
								; V5 = empty
								; V6 = laser.const LASER_ALIVE_XPOS_MAX
								; V7 = laser.const LASER_ALIVE_SPEED_X

  ADD V4, VE							; V4 += global.anim
		 
  ; draw real laser
  CALL func_DrawLaser

  ; if (laser.xpos > laser.const LASER_ALIVE_XPOS_MAX)
  ; then skip to laser_died
  SUB V6, V9
  SE VF, 1							; VF = 1 if laser.xpos <= laser.const LASER_ALIVE_XPOS_MAX
  JP lbl_do_update_laser_died

  ADD V9, V7							; laser.xpos += laser.const LASER_ALIVE_SPEED_X
  
  JP lbl_do_update_laser_switch_end				; break

lbl_do_update_laser_case_hit_enemy:
lbl_do_update_laser_case_hit_wall:

  LD V8, 0							; laser.timer = 0

  LD VB, E_LASER_STATE_DYING					; laser.state = E_LASER_STATE_DYING

  ; fall through

lbl_do_update_laser_case_dying:

  LDHI I, data_laser_dying_constants-4
  LD V7, [I]
								; V4 = E_LASER_SPRITE_DYING_0
								; V5 = empty
								; V6 = empty
								; V7 = laser.const LASER_DYING_TIMER_MAX
    
  ADD V4, V8							; V4 += laser.timer
  
  ; draw laser
  CALL func_DrawLaser
  
  ADD V8, LASER_DYING_TIMER_INC					; laser.timer++

  ; if (laser.timer != laser.const LASER_DYING_TIMER_MAX)
  ; then skip to end
  ; else fall through to died
  SE V8, V7				
  JP lbl_do_update_laser_switch_end

lbl_do_update_laser_died:

  LD VB, E_LASER_STATE_DEAD					; laser.state = E_LASER_STATE_DEAD

  ; fall through 

lbl_do_update_laser_switch_end:

  ; save all laser info
  LDHI I, data_laser_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateEnemies
;---------------------------------------------------------------------------------
func_DoUpdateEnemies:

  ; VC is enemy loop counter
  LD VC, 0							; VC = loop counter

  SPRW ENEMY_WIDTH
  SPRH ENEMY_HEIGHT

lbl_do_update_enemies_loop_start:

  ; load enemy info
  LDHI I, data_enemy_slot_lookup
  ADD I, VC
  LD V3, [I]
  LD I, lbl_do_update_enemies_ptr1
  LD [I], V3
  LD I, lbl_do_update_enemies_ptr2
  LD [I], V3

lbl_do_update_enemies_ptr1:
  LDHI I, lbl_do_update_enemies_ptr1

  LD VB, [I]
								; V5 = enemy.health
								; V6 = enemy.state
  								; V7 = enemy.xpos
  								; V8 = enemy.ypos
								; V9 = enemy.type
								; VA = enemy.move
								; VB = enemy.timer

  ; set up switch
  LDHI I, data_enemy_update_state_switch_lookup
  ADD I, V6
  LD V1, [I]
  LD I, lbl_do_update_enemies_switch_start
  LD [I], V1

lbl_do_update_enemies_switch_start:
  JP lbl_do_update_enemies_switch_start

lbl_do_update_enemies_case_damaged_by_laser:
 
  ; mark the enemy as damaged shield
  LD V6, E_ENEMY_STATE_DAMAGED_SHIELD_1				; enemy.state = E_ENEMY_STATE_DAMAGED_SHIELD_1
  
  LD V4, E_ENEMY_SPRITE_DAMAGED_0
  JP lbl_do_update_enemies_draw_alive

lbl_do_update_enemies_case_damaged_shield_1:
lbl_do_update_enemies_case_damaged_shield_2:
lbl_do_update_enemies_case_damaged_shield_3:

  ; mark the enemy as damaged shield
  ADD V6, #02							; enemy.state = E_ENEMY_STATE_DAMAGED_SHIELD++
  
  LD V4, E_ENEMY_SPRITE_DAMAGED_0
  JP lbl_do_update_enemies_draw_alive

lbl_do_update_enemies_case_damaged_shield_last:

  ; mark the enemy as alive again
  LD V6, E_ENEMY_STATE_ALIVE					; enemy.state = E_ENEMY_STATE_ALIVE
  
  LD V4, E_ENEMY_SPRITE_DAMAGED_0
  JP lbl_do_update_enemies_draw_alive

lbl_do_update_enemies_case_alive:
  
  LD V4, E_ENEMY_SPRITE_ALIVE_0
  
  ; fall through to draw

lbl_do_update_enemies_draw_alive:
								; V4 is either E_ENEMY_SPRITE_DAMAGED_0 + global.anim
  ADD V4, VE							; or E_ENEMY_SPRITE_ALIVE_0 + global.anim

  ; draw enemy
  CALL func_DrawEnemy

  LDHI I, data_enemy_alive_constants-2
  LD V4, [I]
								; V2 = enemy.const ENEMY_ALIVE_X_MOVE_MASK
								; V3 = enemy.const ENEMY_ALIVE_Y_MOVE_MASK
								; V4 = enemy.const ENEMY_ALIVE_XPOS_MIN

  AND V2, VA
  SUB V7, V2							; enemy.xpos -= (enemy.move & enemy.const ENEMY_ALIVE_X_MASK)

  ; if (enemy.xpos <= enemy.const ENEMY_ALIVE_XPOS_MIN)
  ; then skip to dying_alive
  SUB V4, V7			
  SNE VF, 1							; VF = 1 if enemy.xpos <= enemy.const ENEMY_ALIVE_XPOS_MIN
  JP lbl_do_update_enemies_died

  AND V3, VA							
  LDHI I, data_enemy_y_movement_lookup
  ADD I, V3
  LD V3, [I]  
  LD I, lbl_do_update_enemies_ptr3
  LD [I], V3
lbl_do_update_enemies_ptr3:
  LDHI I, lbl_do_update_enemies_ptr3
  ADD I, VB
  LD V0, [I]
  ADD V8, V0							; enemy.ypos += delta[movement[enemy.move & enemy.const ENEMY_ALIVE_Y_MASK]]
  
  ADD VB, ENEMY_MOVEMENT_LOOKUP_INC				; enemy.timer++

  JP lbl_do_update_enemies_switch_end				; break

lbl_do_update_enemies_case_killed_by_laser:
 
  ; load game.score
  LDHI I, data_game_scoreinfo-0			
  LD V3, [I]						
								; V0 = game.score 100s
								; V1 = game.score 10s
								; V2 = game.score 1s
								; V3 = game.score
  ; increment
  ADD V3, GAME_SCORE_INC					; game.score++
  
  ; set BCD
  LD B, V3
  LDHI I, data_game_scoreinfo-0
  LD V2, [I]
  SHL V0
  SHL V0
  SHL V1
  SHL V1
  SHL V2
  SHL V2

  ; save updated game.score
  LD [I], V3

  ; fall through

lbl_do_update_enemies_case_hit_something:

  LD V6, E_ENEMY_STATE_DYING					; enemy.state = E_ENEMY_STATE_DYING
  
  LD VB, 0							; enemy.timer = 0

 ; fall through  

lbl_do_update_enemies_case_dying:

  LD V4, E_ENEMY_SPRITE_DYING_0					; V4 = E_ENEMY_STATE_DYING_0 + enemy.timer
  ADD V4, VB

  ; draw enemy
  CALL func_DrawEnemy

  LDHI I, data_enemy_dying_constants-2
  LD V4, [I]
  								; V2 = player.const ENEMY_DYING_XPOS_MIN
 								; V3 = player.const ENEMY_DYING_SPEED_X 
  								; V4 = player.const ENEMY_DYING_TIMER_MAX
  
  ADD VB, ENEMY_DYING_TIMER_INC					; enemy.timer++

  ; if (enemy.timer == enemy.const ENEMY_DYING_TIMER_MAX)
  ; then enemy died
  SNE VB, V4
  JP lbl_do_update_enemies_died

  ; if (enemy.xpos <= enemy.const ENEMY_DYING_XPOS_MIN)
  ; then skip to died
  SUB V2, V7			
  SNE VF, 1							; VF = 1 if enemy.xpos <= enemy.const ENEMY_DYING_XPOS_MIN
  JP lbl_do_update_enemies_died
 
  SUB V7, V3							; enemy.xpos -= enemy.const ENEMY_DYING_SPEED_X
 
  JP lbl_do_update_enemies_switch_end				; break

lbl_do_update_enemies_died:
				
  LD V6, E_ENEMY_STATE_DEAD					; enemy.state = E_ENEMY_STATE_DEAD

  ; fall through to case dead

lbl_do_update_enemies_case_dead:

  ; empty 

lbl_do_update_enemies_switch_end:

lbl_do_update_enemies_ptr2:
  LDHI I, lbl_do_update_enemies_ptr2

  ; save enemy
  LD [I], VB

lbl_do_update_enemies_loop_next:  
  
  ; if (loop == ENEMY_SLOT_MAX)
  ; then end test nicely
  ADD VC, ENEMY_SLOT_INC
  SE VC, E_ENEMY_SLOT_MAX
  JP lbl_do_update_enemies_loop_start

lbl_do_update_enemies_end:

  RET 
;---------------------------------------------------------------------------------







;---------------------------------------------------------------------------------
; func_DoUpdateBoss
;---------------------------------------------------------------------------------
func_DoUpdateBoss:

  ; load boss info
  LDHI I, data_boss_info-8
  LD VC, [I]
								; V8 = boss.health
								; V9 = boss.state
  								; VA = boss.xpos
  								; VB = boss.ypos
								; VC = boss.timer

  ; set up switch
  LDHI I, data_boss_update_switch_lookup
  ADD I, V9
  LD V1, [I]
  LD I, lbl_do_boss_update_switch_start
  LD [I], V1

lbl_do_boss_update_switch_start:
  JP lbl_do_boss_update_switch_start

lbl_do_boss_update_case_damaged_by_laser:

  ; load damaged constants
  LDHI I, data_boss_damaged_constants-4
  LD V7, [I]
               							; V4 = E_BOSS_SPRITE_DAMAGED
             							; V5 = unused
              							; V6 = boss.const BOSS_DAMAGED_TIMER_INC
								; V7 = boss.const BOSS_DAMAGED_TIMER_MAX

  ADD VC, V6							; boss.timer += BOSS_DAMAGED_TIMER_INC
  
  ; if (boss.timer == boss.const BOSS_DAMAGED_TIMER_MAX)
  ; then boss is back to alive
  SE VC, V7
  JP lbl_do_boss_update_draw_overeye

  LD V9, E_BOSS_STATE_ALIVE					; boss.state = E_BOSS_STATE_ALIVE

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_blink:

  ; load blink constants
  LDHI I, data_boss_blink_constants-4
  LD V7, [I]
                						; V4 = E_BOSS_SPRITE_BLINK
               							; V5 = unused
    								; V6 = boss.const BOSS_BLINK_TIMER_INC
								; V7 = boss.const BOSS_BLINK_TIMER_MAX

  ADD VC, V6							; boss.timer += BOSS_BLINK_TIMER_INC

  ; if (boss.timer == boss.const BOSS_BLINK_TIMER_MAX)
  ; then boss is back to alive
  SE VC, V7
  JP lbl_do_boss_update_draw_overeye

  LD V9, E_BOSS_STATE_ALIVE					; boss.state = E_BOSS_STATE_ALIVE

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_alive:

  ; random chance to blink
  RND V0, BOSS_ALIVE_BLINK_CHANCE 
  SE V0, 0
  JP lbl_do_boss_update_switch_end				; break

  ; do a blink
  LD VC, 0							; boss.timer = 0
  LD V9, E_BOSS_STATE_BLINK					; boss.state = E_BOSS_STATE_BLINK
  
  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_draw_overeye:

  ; draw boss
  SPRW BOSS_WIDTH
  SPRH BOSS_HEIGHT
  CALL func_DrawBossEye

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_killed_by_laser:

  ; boss should start dying
  LD VC, 0							; boss.timer = 0
  LD V9, E_BOSS_STATE_DYING					; boss.state = E_BOSS_STATE_DYING
 
  ; fall through

lbl_do_boss_update_case_dying:

  ; load dying constants
  LDHI I, data_boss_dying_constants-4
  LD V7, [I]							; V4 = E_BOSS_SPRITE_DYING_0
								; V5 = unused
								; V6 = boss.const BOSS_DYING_TIMER_INC
								; V7 = boss.const BOSS_DYING_TIMER_MAX 

  ADD V4, VE							; V4 += boss.globalanim

  SPRW BOSS_WIDTH
  SPRH BOSS_HEIGHT
  CALL func_DrawBossEye

  JP lbl_do_boss_update_switch_end

lbl_do_boss_update_died:
  
  LD V9, E_BOSS_STATE_DEAD					; boss.state = E_BOSS_STATE_DEAD

  ; load game lives info
  LD I, data_game_livesinfo-0
  LD V3, [I]
								; V0 = game.lives
								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								; V2 = game.const GAME_LIVES_BOSS_SHIFT
								; V3 = game.const GAME_LIVES_WIN_SHIFT

  ADD V0, V3							; game.lives += GAME_LIVES_WIN_SHIFT

  ; save updated game lives info	
  LD [I], V3

  ; fall through to case dead

lbl_do_boss_update_case_dead:

  ; empty

lbl_do_boss_update_switch_end:

  ; save boss
  LDHI I, data_boss_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBackgroundAndParallax
;---------------------------------------------------------------------------------
func_DrawBackgroundAndParallax:

  SPRW BACKGROUND_WIDTH
  SPRH BACKGROUND_HEIGHT
  LDHI I, data_sprite_background

  LD V0, 0
  DRW V0, V0, 1

  SPRW PARALLAX_WIDTH
  SPRH PARALLAX_HEIGHT

  LDHI I, data_sprite_parallax_A
  LD V6, 8

  SNE VD, GAMEPLAY_GLOBALDATA_MAX
  JP lbl_use_parallax_A

  ; set xpos draw position
  LD V6, 64
  SUB V6, VE
  SHR V6
  SHR V6
  SHR V6							; V6 = (64 - global.anim) / 8

  LD V1, #01
  AND V1, VD
  SE V1, 1
  JP lbl_use_parallax_A

  LDHI I, data_sprite_parallax_B

lbl_use_parallax_A:  

  DRW V6, V0, 1

  RET
;---------------------------------------------------------------------------------


 
;---------------------------------------------------------------------------------
; func_DrawBorder
;---------------------------------------------------------------------------------
func_DrawBorder:

  SPRW BORDER_WIDTH
  SPRH BORDER_HEIGHT

  LDHI I, data_sprite_border
  LD V0, 0
  DRW V0, V0, 1

  LDHI I, data_game_scoreinfo-4
  LD VB, [I]
								; V4 = game.score 100s
								; V5 = game.score 10s
								; V6 = game.score 1s
								; V7 = game.score
								; V8 = game.const GAME_SCORE_Y_POS
								; V9 = game.const GAME_SCORE_100S_X_POS
								; VA = game.const GAME_SCORE_10S_X_POS
								; VB = game.const GAME_SCORE_1S_X_POS

  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_game_border_score_ptr1
  LD [I], V3
lbl_game_border_score_ptr1:
  LDHI I, lbl_game_border_score_ptr1
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_game_border_score_ptr2
  LD [I], V3
lbl_game_border_score_ptr2:
  LDHI I, lbl_game_border_score_ptr2
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_game_border_score_ptr3
  LD [I], V3
lbl_game_border_score_ptr3:
  LDHI I, lbl_game_border_score_ptr3
  DRW VB, V8, 1

  ; draw lives
  LDHI I, data_game_livesinfo-6
  LD VB, [I]
								; V6 = game.lives
								; V7 = game.const GAME_LIVES_GAMEPLAY_MASK
								; V8 = game.const GAME_LIVES_BOSS_SHIFT
								; V9 = game.const GAME_LIVES_WIN_SHIFT
								; VA = game.const GAME_LIVES_Y_POS
								; VB = game.const GAME_LIVES_X_POS

  LDHI I, data_draw_border_lives_switch_lookup
  ADD I, V6 
  LD V1, [I]
  LD I, lbl_draw_border_lives_switch_start
  LD [I], V1

lbl_draw_border_lives_switch_start:
  JP lbl_draw_border_lives_switch_start

lbl_draw_border_lives_case_lives_3:
lbl_draw_border_lives_case_lives_3_boss:

  LDHI I, data_sprite_number_2
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_lives_2:
lbl_draw_border_lives_case_lives_2_boss:

  LDHI I, data_sprite_number_1
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_lives_1:
lbl_draw_border_lives_case_lives_1_boss:

  LDHI I, data_sprite_number_0
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_game_over:
lbl_draw_border_lives_case_start_screen:
lbl_draw_border_lives_case_lives_1_win:
lbl_draw_border_lives_case_lives_2_win:
lbl_draw_border_lives_case_lives_3_win:
lbl_draw_border_lives_case_null:

  ; empty

lbl_draw_border_lives_switch_end:

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawPlayer
; Draws player sprite index V4 at position [VA, VB]
;---------------------------------------------------------------------------------
func_DrawPlayer:
  
  ; player info must be loaded before func_DrawPlayer is called!
  								; V4 = player sprite
  								; VA = player x-position
  								; VB = player y-position
  LDHI I, data_player_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_player_ptr		
  LD [I], V3		
lbl_draw_player_ptr:
  LDHI I, lbl_draw_player_ptr  

  ; draw player sprite
  DRW VA, VB, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawLaser
; Draws laser sprite index V4 at position [V9, VA]
;---------------------------------------------------------------------------------
func_DrawLaser:
  
  ; laser info must be loaded before func_DrawLaser is called!
  								; V4 = laser sprite
  								; V9 = laser x-position
  								; VA = laser y-position

  LDHI I, data_laser_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_laser_ptr		
  LD [I], V3		
lbl_draw_laser_ptr:
  LDHI I, lbl_draw_laser_ptr  

  ; draw laser sprite
  DRW V9, VA, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawEnemy
; Draws enemy type V9 sprite index V4 at position [V7, V8]
;---------------------------------------------------------------------------------
func_DrawEnemy:
  
  ; enemy info must be loaded before func_DrawEnemy is called!
  								; V4 = enemy sprite
  								; V7 = enemy x-position
  								; V8 = enemy y-position
  								; V9 = enemy type

  ; use enemy.type V9 to set the correct sprite lookup table
  LDHI I, data_enemy_type_lookup
  ADD I, V9
  LD V3, [I]
  LD I, lbl_draw_enemy_lookup_ptr				
  LD [I], V3
lbl_draw_enemy_lookup_ptr:
  LDHI I, lbl_draw_enemy_lookup_ptr
  
  ; and use V4 to draw correct sprite frame
  ADD I, V4
  LD V3, [I]
  LD I, lbl_draw_enemy_sprite_ptr		
  LD [I], V3		
lbl_draw_enemy_sprite_ptr:
  LDHI I, lbl_draw_enemy_sprite_ptr  

  ; draw  enemy sprite
  DRW V7, V8, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBossEye
; Draws boss eye sprite index V4 at position [V9, VA]
;---------------------------------------------------------------------------------
func_DrawBossEye:
  
  ; boss info must be loaded before func_DrawBossEye is called!
  								; V4 = boss eye sprite
  								; VA = boss x-position
  								; VB = boss y-position

  LDHI I, data_boss_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_boss_ptr		
  LD [I], V3		
lbl_draw_boss_ptr:
  LDHI I, lbl_draw_boss_ptr  

  ; draw boss sprite
  DRW VA, VB, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBullet
; Draws bullet sprite index V4 at position [Vx, Vy]
;---------------------------------------------------------------------------------
func_DrawBullet:

  ; bullet info must be loaded before func_DrawBullet is called!
  								; V4 = bullet sprite
  								; Vx = bullet x-position
  								; Vy = bullet y-position

;  LDHI I, data_bullet_sprite_lookup
;  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_bullet_ptr		
  LD [I], V3		
lbl_draw_bullet_ptr:
  LDHI I, lbl_draw_bullet_ptr  

  ; draw bullet sprite
;  DRW Vx, Vy, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawCollisionWalls
; Draws the upper and lower boundary collision walls.
;---------------------------------------------------------------------------------
func_DrawCollisionWalls:

  SPRW WALL_STRIP_WIDTH
  SPRH WALL_STRIP_HEIGHT
  
;  LD V4, VD							; V4 = global.data
  LD V4, 0
  
  LD V5, V4							; V5 = V4 + 15. 
  ADD V5, 15				
  
  ; set xpos draw position
  LD V6, GAMEPLAY_GLOBALANIM_MAX
  SUB V6, VE
  SHR V6
  SHR V6							; V6 = (64 - global.anim) / 4
  
  ; set ypos draw position
  LD V7, WALL_YPOS						; V7 = Wall tile ypos draw position. Never changes.

lbl_draw_collision_walls_loop:

  ; get wall tile index from tile data map
  LDHI I, data_walls_map  
  ADD I, V4							; add tile data offset
  LD V0, [I]
 
  ; get collsion wall sprite from wall collision tile lookup
  LDHI I, data_walls_collision_lookup
  ADD I, V0
  LD V3, [I]
  LD I, lbl_draw_collision_walls_ptr
  LD [I], V3
lbl_draw_collision_walls_ptr:
  LDHI I, lbl_draw_collision_walls_ptr

  ; draw collision wall sprite
  DRW V6, V7, 1
 
  ADD V4, 1							; wall data++
  ADD V6, 16							; wall xpos += 16
  
  ; if still more walls to draw, goto start of loop
  SE V4, V5
  JP lbl_draw_collision_walls_loop

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawRealWalls
; Draws the real upper and lower boundary walls.
;---------------------------------------------------------------------------------
func_DrawRealWalls:

  SPRW WALL_STRIP_WIDTH
  SPRH WALL_STRIP_HEIGHT
  
;  LD V4, VD							; V4 = global.data
  LD V4, 0
  
  LD V5, V4							; V5 = V4 + 15
  ADD V5, 15				
  
  ; set xpos draw position
  LD V6, GAMEPLAY_GLOBALANIM_MAX
  SUB V6, VE
  SHR V6
  SHR V6							; V6 = (64 - global.anim) / 4
  
  ; set ypos draw position
  LD V7, WALL_YPOS						; V7 = Wall tile ypos draw position. Never changes.

lbl_draw_real_walls_loop:

  ; get wall tile index from tile data map
  LDHI I, data_walls_map  
  ADD I, V4							; add tile data offset
  LD V0, [I]
 
  ; get real wall sprite from wall real tile lookup
  LDHI I, data_walls_strip_lookup
  ADD I, V0
  LD V3, [I]
  LD I, lbl_draw_real_walls_ptr
  LD [I], V3
lbl_draw_real_walls_ptr:
  LDHI I, lbl_draw_real_walls_ptr

  ; draw real wall sprite
  DRW V6, V7, 1
 
  ADD V4, 1							; wall data++
  ADD V6, 16							; wall xpos += 16
  
  ; if still more walls to draw, goto start of loop
  SE V4, V5
  JP lbl_draw_real_walls_loop

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; END OF CODE
;---------------------------------------------------------------------------------
lbl_end_code:
  LD I, lbl_end_code
  DA 'All design, code, art and other assets copyright Michael Neve 2012. Brohoof to all. /)'

;---------------------------------------------------------------------------------
; GAME INFO
;---------------------------------------------------------------------------------
INCLUDE 'gameinfo.src'

;---------------------------------------------------------------------------------
; PLAYER INFO
;---------------------------------------------------------------------------------
INCLUDE 'playerinfo.src'

;---------------------------------------------------------------------------------
; LASER INFO
;---------------------------------------------------------------------------------
INCLUDE 'laserinfo.src'

;---------------------------------------------------------------------------------
; ENEMY INFO
;---------------------------------------------------------------------------------
INCLUDE 'enemyinfo.src'
INCLUDE 'enemy_movement.src'
INCLUDE 'boss.src'

;---------------------------------------------------------------------------------
; BULLET INFO
;---------------------------------------------------------------------------------
;INCLUDE 'bulletinfo.src'
INCLUDE 'bullet_movement.src' 

;---------------------------------------------------------------------------------
; WALL INFO
;---------------------------------------------------------------------------------
INCLUDE 'wallinfo.src'

;---------------------------------------------------------------------------------
; GENERIC
;---------------------------------------------------------------------------------

