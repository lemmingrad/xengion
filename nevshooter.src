;---------------------------------------------------------------------------------
; NevShooter copyright Michael Neve 2012
; No, it has nothing to do with shooting me.
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; A note on register usage, for in-game and boss states:
;
;   VF = Reserved for carry/collision. Do not use.
; 
;   Gameplay state:
;   VE = Global anim counter. Loops continuously from 0 to GAME_GLOBALANIM_MAX, step GAME_GLOBALANIM_INC. (global.anim)
;   VD = Data index. Increments by GAME_GLOBALDATA_INC each time VE rolls around, up to GAME_GLOBALDATA_MAX. (global.data)
;
;   VD and VE may have different uses in title/gameplay/boss/game-over states
;---------------------------------------------------------------------------------

  MEGAON							; Megachip8 mode

  LDHI I, data_palette						; Load a palette
  LDPAL PALETTE_SIZE

lbl_main_frame_loop_start:
  
  CLS

  ; load game info
  ; It has the game state (aka number of lives).
  LDHI I, data_game_livesinfo-0
  LD V0, [I]
								; V0 = game.lives

  ; if (game.lives == E_GAME_LIVES_START_SCREEN)
  ; then do title screen
  ; else if (game.lives == E_GAME_LIVES_GAME_OVER)
  ; then do game-over screen
  ; else if (game.lives == E_GAME_LIVES_X)
  ; then do gameplay
  ; else if (game.lives == E_GAME_LIVES_X_BOSS)
  ; then do boss
  ; else if (game.lives == E_GAME_LIVES_X_WIN)
  ; then do win screen

  LDHI I, data_game_main_frame_lives_switch_lookup
  ADD I, V0
  LD V1, [I]
  LD I, lbl_main_frame_lives_switch_start
  LD [I], V1

lbl_main_frame_lives_switch_start:
  JP lbl_main_frame_lives_switch_start

lbl_main_frame_lives_case_start_screen:

  CALL func_DoTitleScreen

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1:
lbl_main_frame_lives_case_lives_2:
lbl_main_frame_lives_case_lives_3:

  CALL func_DoBossplay

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1_boss:
lbl_main_frame_lives_case_lives_2_boss:
lbl_main_frame_lives_case_lives_3_boss:

  CALL func_DoBossplay

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1_win:
lbl_main_frame_lives_case_lives_2_win:
lbl_main_frame_lives_case_lives_3_win:
lbl_main_frame_lives_case_game_over:

  CALL func_DoGameOverScreen

  JP lbl_main_frame_lives_switch_end

lbl_main_frame_lives_case_null:

  ; empty

lbl_main_frame_lives_switch_end:

  ; loop to start
  JP lbl_main_frame_loop_start

  EXIT
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoTitleScreen
;---------------------------------------------------------------------------------
func_DoTitleScreen:

  ; draw title screen sprite
  SPRW TITLE_SCREEN_WIDTH
  SPRH TITLE_SCREEN_HEIGHT
  LDHI I, data_sprite_title_screen
  LD V0, 0
  DRW V0, V0, 1

  ; increment a title screen timer				; VD = gametitle.timer
  SE VD, GAMETITLE_TIMER_MAX
  ADD VD, GAMETITLE_TIMER_INC

  ; load game data 
  LDHI I, data_game_hiscoreinfo-5
  LD VC, [I]
								; V5 = game.hi-score 100s
								; V6 = game.hi-score 10s
								; V7 = game.hi-score 1s
								; V8 = game.hi-score
								; V9 = game.const GAME_HISCORE_Y_POS
								; VA = game.const GAME_HISCORE_100S_X_POS
								; VB = game.const GAME_HISCORE_10S_X_POS
								; VC = game.const GAME_HISCORE_1S_X_POS


  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; draw hi-score 100s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_game_start_screen_ptr1
  LD [I], V3
lbl_game_start_screen_ptr1:
  LDHI I, lbl_game_start_screen_ptr1
  DRW VA, V9, 1

  ; draw hi-score 10s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_game_start_screen_ptr2
  LD [I], V3
lbl_game_start_screen_ptr2:
  LDHI I, lbl_game_start_screen_ptr2
  DRW VB, V9, 1

  ; draw hi-score 1s
  LDHI I, data_number_lookup
  ADD I, V7
  LD V3, [I]
  LD I, lbl_game_start_screen_ptr3
  LD [I], V3
lbl_game_start_screen_ptr3:
  LDHI I, lbl_game_start_screen_ptr3
  DRW VC, V9, 1

  ; if gametitle.timer < GAMETITLE_TIMER_ALLOW_CONTINUE
  ; then return
  LD V0, GAMETITLE_TIMER_ALLOW_CONTINUE
  SUB V0, VD
  SE VF, 0
  RET

  ; if (KEY_START != pressed)
  ; then return
  LD V0, KEY_START
  SKP V0				
  RET

  ; Begin transition into gameplay state
  ; reset lives
  LDHI I, data_game_livesinfo-0
  LD V0, E_GAME_LIVES_3						; game.lives = E_GAME_LIVES_3
  LD [I], V0

  ; reset score
  LDHI I, data_game_scoreinfo-0
  LD V0, 0							; game.score 100s = 0
  LD V1, 0							; game.score 10s = 0
  LD V2, 0							; game.score 1s = 0
  LD V3, 0							; game.score = 0
  LD [I], V3

  ; reset everything else
  CALL func_ResetGameplay

  ; load gameplay threats
  ; CALL func_LoadGameplayThreats					

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_ResetGameplay
;---------------------------------------------------------------------------------
func_ResetGameplay:

  ; reset bullet slots
  ; TODO

  ; reset enemy slots
  ; TODO

  ; reset laser
  LDHI I, data_laser_reset
  LD V4, [I]
  LDHI I, data_laser_info
  LD [I], V4
 
  ; reset player
  LDHI I, data_player_reset
  LD V3, [I]
  LDHI I, data_player_info
  LD [I], V3

  ; reset global.data
  LD VD, 0

  ; reset global.anim
  LD VE, 0 
  
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoGameplay
;---------------------------------------------------------------------------------
func_DoGameplay:

;  CALL func_DoEnemiesVsLaser
;  CALL func_DrawBackgroundAndParallax
;  CALL func_DrawCollisionWalls
;  CALL func_DoLaserVsWalls
;  CALL func_DoPlayerVsWalls
;  CALL func_DoEnemiesVsPlayerOrWalls
;  CALL func_DoPlayerVsEnemies
;  CALL func_DoUpdateBullets
;  CALL func_DoPlayerVsBullets
;  CALL func_DrawRealWalls
;  CALL func_DoUpdateLaser
;  CALL func_DoUpdateEnemies
  CALL func_DoUpdatePlayer

  ; Do special flow control for gameplay state
  ; player.state is already loaded in VC from func_DoUpdatePlayer

lbl_do_gameplay_test_for_player_dead:

  SE V9, E_PLAYER_STATE_DEAD
  JP lbl_do_gameplay_test_for_outro_complete

  CALL func_ResetGameplay
  
  ; decrement game.lives
  LD I, data_game_livesinfo-0				 
  LD V1, [I]
								; V0 = game.lives
  								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								
  AND V0, V1							; game.lives &= GAME_LIVES_GAMEPLAY_MASK
  ADD V0, GAME_LIVES_DEC 					; game.lives--
  LD [I], V0

  JP lbl_do_gameplay_test_end					; break

lbl_do_gameplay_test_for_outro_complete:

  SE V9, E_PLAYER_STATE_OUTRO_COMPLETE
  JP lbl_do_gameplay_test_end

; CALL func_ResetBossplay
;
; ; update lives
;  LD I, data_game_livesinfo-0				 
;  LD V2, [I]
;								; V0 = game.lives
;								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
;								; V2 = game.const GAME_LIVES_BOSS_SHIFT
;  ADD V0, V2							; game.lives += GAME_LIVES_BOSS_SHIFT
;  LD [I], V0

lbl_do_gameplay_test_end:
  
  CALL func_DrawBorder

  ; increment anim counter
  ADD VE, GAMEPLAY_GLOBALANIM_INC				; global.anim++

  ; if (global.anim != 64)
  ; then early exit 
  SE VE, GAMEPLAY_GLOBALANIM_MAX
  RET
  
  LD VE, 0							; global.anim = 0
  
  ; global.data controls the wallinfo and all gameplay threats
  ; During normal gameplay, it doesn't want to pass ~240, because the last screen should be for player outro 
  ; if (global.data == GAMEPLAY_GLOBALDATA_MAX)
  ; then early exit
  SNE VD, GAMEPLAY_GLOBALDATA_MAX
  RET

  ADD VD, GAMEPLAY_GLOBALDATA_INC				; global.data++

  ; load any new enemies or bullets
;  CALL func_LoadGameplayThreats

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_ResetBossplay
;---------------------------------------------------------------------------------
func_ResetBossplay:



  LD VD, 0
  LD VE, 0

;  CALL func_LoadBossplayThreats

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_LoadBossplayThreats
;---------------------------------------------------------------------------------
func_LoadBossplayThreats:

;  LDHI I, data_bossplay_bullet_threats
  ADD I, VD							; load threat for global.data position.
  LD V0, [I]

  ; if no bullet threat
  ; then early return
;  SE V0, NO_BULLET_THREAT										
  RET			

  ; else there is a bullet threat
 
;  LDHI I, data_bullet_threat_lookup-6
  ADD I, V0

  LD VC, [I]
								; V6 = bullet owner enemy slot
								; V7 = bullet slot
								; V8 = bullet.state
								; V9 = bullet.timer
								; VA = bullet.xpos
								; VB = bullet.ypos
								; VC = bullet.move

  ; VC is the owner of the bullet. Is the owner alive?
;  LDHI I, data_enemy_slot_lookup
;  ADD I, V6

;  LD V3, [I]
;  LD I, lbl_load_bossplay_enemy_threat_ptr
;  LD [I], V3
;lbl_load_bossplay_enemy_threat_ptr:
;  LDHI I, lbl_load_bossplay_enemy_threat_ptr
;  LD V5, [I]  
 								; V0 = enemy.state
								; Vx = enemy.xpos
								; Vy = enemy.ypos
  ; if enemy != alive
  ; then early return
  SE V0, E_ENEMY_STATE_ALIVE
  RET

  ; else bullet owner enemy is alive

  ; set bullet position
;  ADD V9, Vx
;  ADD VA, Vy  

  ; copy bullet to bullet slot

;  LD I, lbl_load_bossplay_bullet_threat_ptr
  LD [I], V3

;lbl_load_bossplay_bullet_threat_ptr:
;  LDHI I, lbl_load_bossplay_bullet_threat_ptr
  ; copy threat into registers
  LD VC, [I]
  
  ; copy registers into bullet slot, not including slot value
  LD [I], VB

  ; bullet slot has been updated!

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoBossplay
;---------------------------------------------------------------------------------
func_DoBossplay:

  ; draw collision walls in orange
  LDHI I, data_sprite_boss_background_col
  SPRW BOSS_BACKGROUND_WIDTH
  SPRH BOSS_BACKGROUND_HEIGHT
  LD V0, 0
  DRW V0, V0, 1

  ; draw player collision in orange, test for collision against walls (orange)
  CALL func_DoPlayerVsWalls  
 
  ; draw laser collision in purple, test for collision against walls (orange)
  CALL func_DoLaserVsWalls

  ; draw boss collision in green, test against laser (purple)
  CALL func_DoBossVsLaser

  ; draw enemies collision in green, test for collision against walls (orange), player (also orange) or laser (purple)
  CALL func_DoEnemiesVsMultiCol

  ; draw player collision in orange, test for collision against enemies (green), which will include boss
  CALL func_DoPlayerVsEnemies

  ; draw walls, background, etc
  LDHI I, data_sprite_boss_background
  SPRW BOSS_BACKGROUND_WIDTH
  SPRH BOSS_BACKGROUND_HEIGHT
  LD V0, 0
  DRW V0, V0, 1
 
  CALL func_DoUpdateBullets
;  CALL func_DoPlayerVsBullets
  CALL func_DoUpdateLaser
  CALL func_DoUpdateBoss
  CALL func_DoUpdateEnemies
  CALL func_DoUpdatePlayer

lbl_do_bossplay_test_for_player_dead:

  SE V9, E_PLAYER_STATE_DEAD
  JP lbl_do_gameplay_test_end

  CALL func_ResetGameplay
  
  ; decrement game.lives
  LD I, data_game_livesinfo-0				 
  LD V1, [I]
								; V0 = game.lives
  								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								
  AND V0, V1							; game.lives &= GAME_LIVES_GAMEPLAY_MASK
  ADD V0, GAME_LIVES_DEC 					; game.lives--
  LD [I], V0

  JP lbl_do_bossplay_test_end					; break

lbl_do_bossplay_test_end:















  CALL func_DrawBorder

  ; increment anim counter
  ADD VE, GAMEPLAY_GLOBALANIM_INC				; global.anim++

  ; if (global.anim != 64)
  ; then early exit 
  SE VE, GAMEPLAY_GLOBALANIM_MAX
  RET
 
  LD VE, 0							; global.anim = 0
  
;  ; global.data controls the boss bullets and missiles
;  ADD VD, GAMEBOSS_GLOBALDATA_INC				; global.data++
;
;  SE VD, GAMEBOSS_GLOBALDATA_MAX
;  RET
;
;
;  ; load any new enemies or bullets
;  CALL func_LoadBossThreats

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoGameOverScreen
;---------------------------------------------------------------------------------
func_DoGameOverScreen:

  LDHI I, data_sprite_game_over_screen
  
  LD VE, 0							; VE = cumulative totalscore
  
  ; Draw game over screen sprite
  SPRW GAME_OVER_SCREEN_WIDTH
  SPRH GAME_OVER_SCREEN_HEIGHT
  DRW VE, VE, 1

  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; increment a game over screen timer				; VD = game.gameovertimer
  SE VD, GAMEOVER_SCREEN_TIMER_MAX
  ADD VD, GAMEOVER_SCREEN_TIMER_INC

  LDHI I, data_gameover_screen_enemies_display-8

  LD VC, [I]
								; V8 = game.const GAMEOVER_ENEMIES_Y_POS
 								; V9 = game.const GAMEOVER_ENEMIES_100S_X_POS
								; VA = game.const GAMEOVER_ENEMIES_10S_X_POS
								; VB = game.const GAMEOVER_ENEMIES_1S_X_POS
								; VC = game.const GAMEOVER_TIMER_ENEMIES

  ; if game.gameovertimer < GAMEOVER_TIMER_ENEMIES
  ; then skip to drawing current totalscore
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  ; draw enemies count

  LDHI I, data_game_scoreinfo-4
  LD V7, [I]
								; V4 = game.score 100s
								; V5 = game.score 10s
								; V6 = game.score 1s
								; V7 = game.score  

  LD VE, V7							; totalscore = game.score

  ; draw enemies 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr1
  LD [I], V3
lbl_gameover_enemies_ptr1:
  LDHI I, lbl_gameover_enemies_ptr1
  DRW V9, V8, 1

  ; draw enemies 10s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr2
  LD [I], V3
lbl_gameover_enemies_ptr2:
  LDHI I, lbl_gameover_enemies_ptr2
  DRW VA, V8, 1

  ; draw enemies 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr3
  LD [I], V3
lbl_gameover_enemies_ptr3:
  LDHI I, lbl_gameover_enemies_ptr3
  DRW VB, V8, 1

  ; draw boss and lives counters	

  LDHI I, data_gameover_screen_bosslives-7
  LD VC, [I]
								; V7 = game.const GAMEOVER_LIVES_Y_POS
  								; V8 = game.const GAMEOVER_LIVES_X_POS
 								; V9 = game.const GAMEOVER_BOSS_Y_POS
 								; VA = game.const GAMEOVER_BOSS_X_POS
 								; VB = game.const GAMEOVER_TIMER_LIVES
 								; VC = game.const GAMEOVER_TIMER_BOSS

  ; if game.gameovertimer < GAMEOVER_TIMER_BOSS
  ; then skip to drawing current totalscore
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_game_livesinfo-0
  LD V0, [I]
								; V0 = game.lives

  LDHI I, data_gameover_screen_lives_switch_lookup
  ADD I, V0
  LD V1, [I]
  LD I, lbl_gameover_lives_switch_start
  LD [I], V1

lbl_gameover_lives_switch_start:
  JP lbl_gameover_lives_switch_start

lbl_gameover_lives_case_game_over:

  LDHI I, data_sprite_number_0
  DRW VA, V9, 1
  
  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  DRW V8, V7, 1

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_1_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_0_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_1
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_1_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_2_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_0_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_2
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_1_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_3_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_2_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_3
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_3_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break;

lbl_gameover_lives_case_start_screen:
lbl_gameover_lives_case_lives_1:
lbl_gameover_lives_case_lives_2:
lbl_gameover_lives_case_lives_3:
lbl_gameover_lives_case_lives_1_boss:
lbl_gameover_lives_case_lives_2_boss:
lbl_gameover_lives_case_lives_3_boss:
lbl_gameover_lives_case_null:

  ; empty

lbl_gameover_lives_switch_end:

lbl_gameover_totalscore_ptr1:

  ; draw total score
  LDHI I, data_gameover_screen_score_display-0			
  ; set BCD
  LD B, VE
  
  LDHI I, data_gameover_screen_score_display-5
  LD VC, [I]
								; V5 = reserved for game.resultscore 100s
  								; V6 = reserved for game.resultscore 10s
  								; V7 = reserved for game.resultscore 1s
								; V8 = game.const GAMEOVER_SCORE_Y_POS
  								; V9 = game.const GAMEOVER_SCORE_100S_X_POS
  								; VA = game.const GAMEOVER_SCORE_10S_X_POS
  								; VB = game.const GAMEOVER_SCORE_1S_X_POS
  								; VC = game.const GAMEOVER_TIMER_TOTALSCORE

  SHL V5
  SHL V5
  SHL V6
  SHL V6
  SHL V7
  SHL V7

  LD [I], V7

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr2
  LD [I], V3
lbl_gameover_totalscore_ptr2:
  LDHI I, lbl_gameover_totalscore_ptr2
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr3
  LD [I], V3
lbl_gameover_totalscore_ptr3:
  LDHI I, lbl_gameover_totalscore_ptr3
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V7
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr4
  LD [I], V3
lbl_gameover_totalscore_ptr4:
  LDHI I, lbl_gameover_totalscore_ptr4
  DRW VB, V8, 1

  ; draw hi-score
  LDHI I, data_gameover_screen_hiscore_display-8
  LD VC, [I]
								; V8 = game.const GAMEOVER_HISCORE_Y_POS
  								; V9 = game.const GAMEOVER_HISCORE_100S_X_POS
							  	; VA = game.const GAMEOVER_HISCORE_10S_X_POS
								; VB = game.const GAMEOVER_HISCORE_1S_X_POS
								; VC = game.const GAMEOVER_TIMER_HISCORE

  LDHI I, data_game_hiscoreinfo-4
  LD V7, [I]
								; V4 = current game.hi-score 100s
								; V5 = current game.hi-score 10s
								; V6 = current game.hi-score 1s
								; V7 = current game.hi-score
  
  ; if game.gameovertimer < game.const GAMEOVER_TIMER_HISCORE
  ; then skip to drawing current hi-score
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_hiscore_ptr1

  ; if totalscore < hi-score
  ; then jump to pressed start test
  SUB V7, VE
  SE VF, 0
  JP lbl_gameover_press_start

  LD V7, VE							; new game.hi-score = totalscore

  LDHI I, data_gameover_screen_score_display-4
  LD V6, [I]
								; V4 = new game.hi-score 100s = game.resultscore 100s
								; V5 = new game.hi-score 10s = game.resultscore 10s
								; V6 = new game.hi-score 1s = game.resultscore 1s

  ; save new hi-score
  LDHI I, data_game_hiscoreinfo-4
  LD [I], V7

lbl_gameover_press_start:

  ; if (KEY_START != pressed)
  ; then return
  LD V0, KEY_START
  SKP V0				
  JP lbl_gameover_hiscore_ptr1

  ; go to title screen
  LDHI I, data_game_livesinfo-0
  LD V0, E_GAME_LIVES_START_SCREEN				; game.lives = E_GAME_LIVES_TITLE_SCREEN
  LD [I], V0
  LD VD, 0
  LD VE, 0

  RET

lbl_gameover_hiscore_ptr1:

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr2
  LD [I], V3
lbl_gameover_hiscore_ptr2:
  LDHI I, lbl_gameover_hiscore_ptr2
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup  
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr3
  LD [I], V3
lbl_gameover_hiscore_ptr3:
  LDHI I, lbl_gameover_hiscore_ptr3
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr4
  LD [I], V3
lbl_gameover_hiscore_ptr4:
  LDHI I, lbl_gameover_hiscore_ptr4
  DRW VB, V8, 1

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoLaserVsWalls
; Test laser collision against walls
;---------------------------------------------------------------------------------
func_DoLaserVsWalls:

  ; collision walls should have already been drawn in orange

  ; load laser
  LDHI I, data_laser_info-8
  LD VC, [I]
								; V8 = laser.state
								; V9 = laser.charge
								; VA = laser.timer
								; VB = laser.xpos
								; VC = laser.ypos

  ; if (laser.state != alive)
  ; then early return
  SE V8, E_LASER_STATE_ALIVE
  RET

  ; set collision test colour to orange, since we drew the walls in orange
  CCOL COL_ORANGE

  ; draw laser in purple
  LD V4, E_LASER_SPRITE_COL_PURPLE
  CALL func_DrawLaser

  ; if laser not collided with walls
  ; then early return
  SE VF, 1
  RET
 
  ; laser collided with a wall
  LD V8, E_LASER_STATE_HIT_WALL					; laser.state = E_LASER_STATE_HIT_WALL

  ; save updated laser state
  LDHI I, data_laser_info-8
  LD [I], V8
  
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoPlayerVsWalls
; Test player against collision walls
;---------------------------------------------------------------------------------
func_DoPlayerVsWalls:

  ; collision walls should have already been drawn in orange 

  ; load player
  LDHI I, data_player_info-9
  LD VC, [I]		
								; V9 = player.state
								; VA = player.timer	
								; VB = player.xpos
								; VC = player.ypos

  ; if (player.state != alive)
  ; then return
  SE V9, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to orange
  CCOL COL_ORANGE

  ; draw player, also in orange
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against walls
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD V9, E_PLAYER_STATE_HIT_WALL

  ; save player state
  LDHI I, data_player_info-9
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; func_DoPlayerVsEnemies
; Test player against collision enemies
;---------------------------------------------------------------------------------
func_DoPlayerVsEnemies:

  ; collision enemies should have already been drawn in green
  ; This will also test against boss if boss collision has been drawn in green 

  ; load player
  LDHI I, data_player_info-9
  LD VC, [I]		
								; V9 = player.state
								; VA = player.timer	
								; VB = player.xpos
								; VC = player.ypos

  ; if (player.state != alive)
  ; then return
  SE V9, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to green
  CCOL COL_GREEN

  ; draw player, in orange
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against enemies
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD V9, E_PLAYER_STATE_HIT_ENEMY

  ; save player state
  LDHI I, data_player_info-9
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; func_DoPlayerVsBullets
; Test player against collision bullets
;---------------------------------------------------------------------------------
func_DoPlayerVsBullets:

  ; collision bullets should have already been drawn in purple
  ; this will also test collision against laser, MAKE SURE PLAYER AND LASER NEVER OVERLAP

  ; load player
  LDHI I, data_player_info-9
  LD VC, [I]		
								; V9 = player.state
								; VA = player.timer	
								; VB = player.xpos
								; VC = player.ypos

  ; if (player.state != alive)
  ; then return
  SE V9, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to purple
  CCOL COL_PURPLE

  ; draw player, in orange
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against bullets
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD V9, E_PLAYER_STATE_HIT_BULLET

  ; save player state
  LDHI I, data_player_info-9
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoBossVsLaser
;---------------------------------------------------------------------------------
func_DoBossVsLaser:

  ; laser should already have been drawn in purple

  ; load boss info
  LDHI I, data_boss_info-8
  LD VC, [I]
								; V8 = boss.state
								; V9 = boss.health
								; VA = boss.timer
								; VB = boss.xpos
								; VC = boss.ypos
								
  ; set collision test colour to purple, since laser was drawn in purple
  CCOL COL_PURPLE

  LD V4, E_BOSS_SPRITE_COL_GREEN
  CALL func_DrawBossEye

  ; if no collision
  ; then return early
  SE VF, 1
  RET 

  ; load laser info
  LDHI I, data_laser_info-6
  LD V7, [I]	
								; V6 = laser.state
								; V7 = laser.charge

  ; there was a collision between laser and boss
  ; logic is something like this:
  ; if (laser.charge == boss.health)
  ; then laser=dying, boss=dying
  ; else if (laser.charge < boss.health)
  ; then boss.health -= laser.charge, laser=dying
  ; else laser.charge -= boss.charge, enemy=dying

  ; special case for boss: if boss is not 'alive', it takes no damage
  SE V8, E_BOSS_STATE_ALIVE
  JP lbl_boss_vs_laser_no_damage

  ; if laser.charge != boss.health
  ; then goto laser.charge < boss.health test
  SE V7, V9
  JP lbl_boss_vs_laser_less_than

  ; laser.charge == enemy.health, both are dying
  LD V6, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  LD V8, E_BOSS_STATE_KILLED_BY_LASER 				; boss.state = E_BOSS_STATE_KILLED_BY_LASER
   
  ; laser has no more charge, end test
  JP lbl_boss_vs_laser_end					; break
   
lbl_boss_vs_laser_less_than:
  ; if laser.charge > boss.health
  ; then goto laser.charge > boss.health branch
  LD V0, V9
  SUB V0, V7
  SE VF, 1
  JP lbl_boss_vs_laser_greater_than
  
  ; laser.charge < boss.health
  LD VA, 0							; boss.timer = 0
  LD V8, E_BOSS_STATE_DAMAGED_BY_LASER 				; boss.state = E_ENEMY_STATE_DAMAGED_BY_LASER
  SUB V9, V7							; boss.health -= laser.charge
  LD V6, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  
  JP lbl_boss_vs_laser_end					; break

lbl_boss_vs_laser_greater_than:

  SUB V7, V9							; laser.charge -= boss.health
  LD V8, E_BOSS_STATE_KILLED_BY_LASER 				; boss.state = E_BOSS_STATE_KILLED_BY_LASER
  
  JP lbl_boss_vs_laser_end					; break

lbl_boss_vs_laser_no_damage:

  LD V7, 0							; laser.charge = 0
  LD V6, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  
lbl_boss_vs_laser_end:

  ; save laser
  LD [I], V7
  
  ; save boss
  LDHI I, data_boss_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------




















;---------------------------------------------------------------------------------
; func_DoEnemiesVsMultiCol
;---------------------------------------------------------------------------------
func_DoEnemiesVsMultiCol:

  ; collision walls should have already been drawn in orange
  ; collision player should have also been drawn in orange  
  ; collision laser should have already been drawn in purple

  ; VC is now our enemy loop counter/indexer			; VC = enemy looper
  LD VC, 0	
  
  ; set enemy sprite params
  SPRW ENEMY_WIDTH
  SPRH ENEMY_HEIGHT

lbl_enemies_vs_multicol_loop_start:

  ; load enemy info
  LDHI I, data_enemy_slot_lookup
  ADD I, VC
  LD V3, [I]
  LD I, lbl_enemies_vs_multicol_ptr1
  LD [I], V3
  LD I, lbl_enemies_vs_multicol_ptr2
  LD [I], V3

lbl_enemies_vs_multicol_ptr1:
  LDHI I, lbl_enemies_vs_multicol_ptr1

  LD VB, [I]
								; V5 = enemy.state
								; V6 = enemy.health
  								; V7 = enemy.timer
  								; V8 = enemy.xpos
								; V9 = enemy.ypos
								; VA = enemy.type
								; VB = enemy.move

  ; if (enemy.state != alive)
  ; then do next enemy
  SE V5, E_ENEMY_STATE_ALIVE
  JP lbl_enemies_vs_multicol_loop_next

  ; else enemy is alive

  ; set collision test colour to orange to test for a collision against walls or player
  CCOL COL_ORANGE
  
   ; draw enemy in green
  LD V4, E_ENEMY_SPRITE_COL_GREEN_A
  CALL func_DrawEnemy

  ; if enemy collided with orange
  ; then jump to orange collision branch
  SNE VF, 1
  JP lbl_enemies_vs_multicol_hit_orange

  ; else no collision
  ; change collision test colour to purple, to test against laser collision
  CCOL COL_PURPLE
 
  ; redraw enemy
  LD V4, E_ENEMY_SPRITE_COL_GREEN_B
  CALL func_DrawEnemy

  ; if enemy collided with purple
  ; then jump to purple collision branch
  SNE VF, 1
  JP lbl_enemies_vs_multicol_hit_purple

  ; else enemy didn't hit anything
  
  JP lbl_enemies_vs_multicol_loop_next				

lbl_enemies_vs_multicol_hit_orange:

  LD V5, E_ENEMY_STATE_HIT_PLAYER_OR_WALL

  JP lbl_enemies_vs_multicol_loop_next
    
lbl_enemies_vs_multicol_hit_purple:

  ; load laser info
  LDHI I, data_laser_info-3
  LD V4, [I]

  ; if laser is not alive
  ; the goto next enemy
  SE V3, E_LASER_STATE_ALIVE
  JP lbl_enemies_vs_multicol_loop_next

  ; else laser is alive

  ; logic is something like this:
  ; if (laser.charge == enemy.health)
  ; then laser=dying, enemy=dying
  ; else if (laser.charge < enemy.health)
  ; then enemy.health -= laser.charge, laser=dying
  ; else laser.charge -= enemy.charge, enemy=dying

  ; if laser.charge == enemy.health
  ; then goto laser.charge == enemy.health branch
  SNE V4, V6
  JP lbl_enemies_vs_multicol_laser_equal

  ; else
  ; if laser.charge > enemy.health
  ; then goto laser.charge > enemy.health branch
  LD V0, V6
  SUB V0, V4
  SE VF, 1							; VF = 1 if enemy.health >= laser.charge
  JP lbl_enemies_vs_multicol_laser_greater
  
  ; else laser.charge < enemy.health

  LD V5, E_ENEMY_STATE_DAMAGED_BY_LASER 			; enemy.state = E_ENEMY_STATE_DAMAGED_BY_LASER
  SUB V6, V4							; enemy.health -= laser.charge
  LD V3, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  
  JP lbl_enemies_vs_multicol_laser_end

lbl_enemies_vs_multicol_laser_greater:

  SUB V4, V6							; laser.charge -= enemy.health
  LD V5, E_ENEMY_STATE_KILLED_BY_LASER 				; enemy.state = E_ENEMY_STATE_KILLED_BY_LASER

  JP lbl_enemies_vs_multicol_laser_end

lbl_enemies_vs_multicol_laser_equal:

  LD VB, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  LD V5, E_ENEMY_STATE_KILLED_BY_LASER 				; enemy.state = E_ENEMY_STATE_KILLED_BY_LASER
  
  ; fall through  

lbl_enemies_vs_multicol_laser_end:

  ; save laser info
  LD [I], V4

  ; fall through

lbl_enemies_vs_multicol_loop_next:

lbl_enemies_vs_multicol_ptr2:
  LDHI I, lbl_enemies_vs_multicol_ptr2

  ; save enemy
  LD [I], VB

  ; if (loop != ENEMY_SLOT_MAX)
  ; then goto start of loop
  ADD VC, ENEMY_SLOT_INC
  SE VC, E_ENEMY_SLOT_MAX
  JP lbl_enemies_vs_multicol_loop_start

lbl_enemies_vs_multicol_end:

  RET 
;---------------------------------------------------------------------------------
  


;---------------------------------------------------------------------------------
; func_DoUpdateBullets
;---------------------------------------------------------------------------------
func_DoUpdateBullets:

  ; VC is bullet loop counter
  LD VC, 0							; VC = loop counter

  SPRW BULLET_WIDTH
  SPRH BULLET_HEIGHT

lbl_do_update_bullets_loop_start:

  ; load bullet info
  LDHI I, data_bullet_slot_lookup
  ADD I, VC
  LD V3, [I]
  LD I, lbl_do_update_bullets_ptr1
  LD [I], V3
  LD I, lbl_do_update_bullets_ptr2
  LD [I], V3

lbl_do_update_bullets_ptr1:
  LDHI I, lbl_do_update_bullets_ptr1

  LD VB, [I]
								; V6 = bullet.state
  								; V7 = bullet.owner
  								; V8 = bullet.timer
								; V9 = bullet.xpos
								; VA = bullet.ypos
								; VB = bullet.move

  ; if (bullet.state != alive)
  ; then do next bullet
  SE V6, E_BULLET_STATE_ALIVE
  JP lbl_do_update_bullets_loop_next

  ; else bullet is alive

  LDHI I, data_bullet_x_movement_lookup
  ADD I, VB
  LD V3, [I]
  LD I, lbl_do_update_bullets_ptr_x
  LD [I], V3

lbl_do_update_bullets_ptr_x:
  LDHI I, lbl_do_update_bullets_ptr_x
  ADD I, V8
  LD V0, [I]
  ADD V9, V0
 
  LDHI I, data_bullet_y_movement_lookup
  ADD I, VB
  LD V3, [I]
  LD I, lbl_do_update_bullets_ptr_y
  LD [I], V3

lbl_do_update_bullets_ptr_y:
  LDHI I, lbl_do_update_bullets_ptr_y
  ADD I, V8
  LD V0, [I]
  ADD VA, V0


  LD V4, E_BULLET_SPRITE_ALIVE_0
  ADD V4, VE
  CALL func_DrawBullet  

  ADD V8, 1
  
  
lbl_do_update_bullets_loop_next:

lbl_do_update_bullets_ptr2:
  LDHI I, lbl_do_update_bullets_ptr2

  ; save bullet
  LD [I], VB

  ; if (loop != BULLET_SLOT_MAX)
  ; then goto start of loop
  ADD VC, BULLET_SLOT_INC
  SE VC, E_BULLET_SLOT_MAX
  JP lbl_do_update_bullets_loop_start

lbl_do_update_bullets_end:

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateLaser
;---------------------------------------------------------------------------------
func_DoUpdateLaser:

  ; load laser info
  LDHI I, data_laser_info-8
  LD VC, [I]
								; V8 = laser.state
								; V9 = laser.charge
		  						; VA = laser.timer
  								; VB = laser.xpos
								; VC = laser.ypos
  
  ; set up switch
  LDHI I, data_laser_update_state_switch_lookup
  ADD I, V8				
  LD V1, [I]
  LD I, lbl_do_update_laser_switch_start
  LD [I], V1

lbl_do_update_laser_switch_start:
  JP lbl_do_update_laser_switch_start

lbl_do_update_laser_case_dead:

  LDHI I, data_laser_dead_constants-4
  LD V7, [I]
								; V4 = laser.const LASER_DEAD_CHARGE
								; V5 = laser.const LASER_DEAD_OFFSET_X
								; V6 = laser.const LASER_DEAD_OFFSET_Y  
								; V7 = laser.const KEY_FIRE
  ; if (KEY_FIRE != pressed)
  ; then jump to end of switch
  SKP V7							; test KEY_FIRE pressed
  JP lbl_do_update_laser_switch_end				; break

  LDHI I, data_player_info-0
  LD V3, [I]						
								; V0 = player.state
								; V1 = player.timer
								; V2 = player.xpos
								; V3 = player.ypos
  ; if (player != alive)
  ; then jump to end of switch
  SE V0, E_PLAYER_STATE_ALIVE					; cannot fire if player is not alive
  JP lbl_do_update_laser_switch_end				; break
  
  ; laser is now alive
  LD VB, V2
  ADD VB, V5							; laser.xpos = player.xpos + laser.const LASER_DEAD_OFFSET_X

  LD VC, V3
  ADD VC, V6							; laser.ypos = player.ypos + laser.const LASER_DEAD_OFFSET_Y

  LD V8, E_LASER_STATE_ALIVE					; laser.state = E_LASER_STATE_ALIVE
  LD V9, V4							; laser.charge = laser.const LASER_DEAD_CHARGE
  
  JP lbl_do_update_laser_switch_end				; break
    
lbl_do_update_laser_case_alive:
  
  LDHI I, data_laser_alive_constants-4
  LD V7, [I]
								; V4 = E_LASER_SPRITE_ALIVE_0
								; V5 = empty
								; V6 = laser.const LASER_ALIVE_XPOS_MAX
								; V7 = laser.const LASER_ALIVE_SPEED_X

  ADD V4, VE							; V4 += global.anim
  CALL func_DrawLaser

  ADD VB, V7							; laser.xpos += laser.const LASER_ALIVE_SPEED_X

  ; if (laser.xpos > laser.const LASER_ALIVE_XPOS_MAX)
  ; then skip to laser died
  SUB V6, VB
  SE VF, 1							; VF = 1 if laser.xpos <= laser.const LASER_ALIVE_XPOS_MAX
  JP lbl_do_update_laser_now_dead

  ; else laser is still alive
  
  JP lbl_do_update_laser_switch_end				; break

lbl_do_update_laser_case_hit_enemy:
lbl_do_update_laser_case_hit_wall:

  LD VA, 0							; laser.timer = 0
  LD V8, E_LASER_STATE_DYING					; laser.state = E_LASER_STATE_DYING

  ; fall through to dying

lbl_do_update_laser_case_dying:

  LDHI I, data_laser_dying_constants-4
  LD V7, [I]
								; V4 = E_LASER_SPRITE_DYING_0
								; V5 = empty
								; V6 = laser.const LASER_DYING_TIMER_INC
								; V7 = laser.const LASER_DYING_TIMER_MAX
    
  ADD V4, VA							; V4 += laser.timer
  CALL func_DrawLaser

  ADD VA, V6							; laser.timer += laser.const LASER_DYING_TIMER_INC

  ; if (laser.timer == laser.const LASER_DYING_TIMER_MAX)
  ; then laser died
  SNE VA, V7				
  JP lbl_do_update_laser_now_dead

  ; else laser is still dying
  
  JP lbl_do_update_laser_switch_end				; break  

lbl_do_update_laser_now_dead:

  LD V8, E_LASER_STATE_DEAD					; laser.state = E_LASER_STATE_DEAD

  JP lbl_do_update_laser_switch_end				; break  

lbl_do_update_laser_switch_end:

  ; save all laser info
  LDHI I, data_laser_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdatePlayer
;---------------------------------------------------------------------------------
func_DoUpdatePlayer:

  ; load player info
  LDHI I, data_player_info-9
  LD VC, [I]
								; V9 = player.state
 		  						; VA = player.timer
  								; VB = player.xpos
								; VC = player.ypos

  ; set up switch
  LDHI I, data_player_update_state_switch_lookup
  ADD I, V9
  LD V1, [I]
  LD I, lbl_do_update_player_switch_start
  LD [I], V1

lbl_do_update_player_switch_start:
  JP lbl_do_update_player_switch_start

lbl_do_update_player_case_reviving:

  LDHI I, data_player_reviving_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_REVIVING_0
								; V5 = unused
   								; V6 = player.const PLAYER_REVIVING_SPEED_X
								; V7 = player.const PLAYER_REVIVING_TIMER_INC
								; V8 = player.const PLAYER_REVIVING_TIMER_MAX

  ; player reviving uses global.anim counter for animation
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  ADD VA, V7							; player.timer += player.const PLAYER_REVIVNG_TIMER_INC

  ; if (player.timer == player.const PLAYER_REVIVING_TIMER_MAX)
  ; then player is now alive
  SNE VA, V8
  JP lbl_do_update_player_now_alive

  ; else player is still reviving
  ADD VB, V6							; player.xpos += player.const PLAYER_REVIVING_SPEED_X

  JP lbl_do_update_player_switch_end				; break
  
lbl_do_update_player_case_hit_wall:
lbl_do_update_player_case_hit_enemy:
lbl_do_update_player_case_hit_bullet:

  LD VA, 0							; player.timer = 0
  LD V9, E_PLAYER_STATE_DYING					; player.state = E_PLAYER_STATE_DYING

  ; fall through to case_dying

lbl_do_update_player_case_dying:

  LDHI I, data_player_dying_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_DYING_0
								; V5 = player.const PLAYER_DYING_XPOS_MIN
								; V6 = player.const PLAYER_DYING_SPEED_X
								; V7 = player.const PLAYER_DYING_TIMER_INC
								; V8 = player.const PLAYER_DYING_TIMER_MAX
 
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  ADD VA, V7							; player.timer += player.const PLAYER_DYING_TIMER_INC

  ; if (player.timer == player.const PLAYER_DYING_TIMER_MAX)
  ; then skip to player has died
  SNE VA, V8
  JP lbl_do_update_player_now_dead			

  SUB VB, V6							; player.xpos -= player.const PLAYER_DYING_SPEED_X

  ; if (player.xpos <= player.const PLAYER_DYING_XPOS_MIN)
  ; then skip player has died
  SUB V5, VB			
  SNE VF, 1							; VF = 0 if player.xpos > player.const PLAYER_DYING_XPOS_MIN
  JP lbl_do_update_player_now_dead				

  ; else player is still dying

  JP lbl_do_update_player_switch_end 				; break

lbl_do_update_player_case_outro:

  LDHI I, data_player_outro_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_REVIVING_0
  								; V5 = unused
								; V6 = unused
								; V7 = player.const PLAYER_OUTRO_XPOS_MAX
								; V8 = player.const PLAYER_OUTRO_SPEED_X
 
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer
  
  ADD VA, V7							; player.xpos += player.const PLAYER_OUTRO_SPEED_X

  ; if (player.xpos > player.const PLAYER_DYING_XPOS_MIN)
  ; then skip to player has succeeded
  SUB V7, VB			
  SNE VF, 0							; VF = 0 if player.xpos > player.const PLAYER_OUTRO_XPOS_MAX
  JP lbl_do_update_player_now_outro_complete			

  ; else player is still outro-ing

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_case_invulnerable:

  LDHI I, data_player_invulnerable_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_REVIVING_0
  								; V5 = unused
								; V6 = unused
  								; V7 = unused
								; V8 = unused

  ; player is invulnerable
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  JP lbl_do_update_player_switch_end				; break 

lbl_do_update_player_now_outro_complete:

  ; player has finished outro
  LD VC, E_PLAYER_STATE_OUTRO_COMPLETE				; player.state = E_PLAYER_STATE_OUTRO_COMPLETE	
  
  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_now_dead:
  
  ; player has died
  LD V9, E_PLAYER_STATE_DEAD					; player.state = E_PLAYER_STATE_DEAD  

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_case_outro_complete:
lbl_do_update_player_case_dead:

  ; empty - do nothing

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_now_alive:

  LD V9, E_PLAYER_STATE_ALIVE					; player.state = E_PLAYER_STATE_ALIVE

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_case_alive:

  ; player alive uses global.anim counter for animation
  LD V4, E_PLAYER_SPRITE_ALIVE_0
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  LDHI I, data_player_alive_constants-0
  LD V8, [I]
								; V0 = player.const PLAYER_ALIVE_XPOS_MIN
								; V1 = player.const PLAYER_ALIVE_XPOS_MAX
								; V2 = player.const PLAYER_ALIVE_SPEED_X
								; V3 = player.const PLAYER_ALIVE_SPEED_Y
								; V4 = E_PLAYER_SPRITE_ALIVE_0
								; V5 = player.const KEY_RIGHT 
								; V6 = player.const KEY_LEFT
								; V7 = player.const KEY_DOWN
								; V8 = player.const KEY_UP

  ; if (KEY_RIGHT != pressed)
  ; then jump to key_left test
  SKP V5							; test KEY_RIGHT pressed
  JP lbl_do_update_player_left_key_test

  ; if (player.xpos > player.const PLAYER_ALIVE_XPOS_MAX)
  ; then jump to key_left test
  SUB V1, VB
  SE VF, 1							; VF = 0 if player.xpos > player.const PLAYER_ALIVE_XPOS_MAX
  JP lbl_do_update_player_left_key_test

  ADD VB, V2							; player.xpos += player.const PLAYER_ALIVE_SPEED_X 

lbl_do_update_player_left_key_test:
  ; if (KEY_LEFT != pressed)
  ; then jump to key_down test
  SKP V6							; test KEY_LEFT pressed
  JP lbl_do_update_player_down_key_test

  ; if (player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN)
  ; then jump to key_down test
  SUB V0, VB						
  SNE VF, 1							; VF = 1 if player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN
  JP lbl_do_update_player_down_key_test
  
  SUB VB, V2							; player.xpos -= player.const PLAYER_ALIVE_SPEED_X

lbl_do_update_player_down_key_test:
  ; if (KEY_DOWN != pressed)
  ; then jump to key_up test
  SKP V7
  JP lbl_do_update_player_up_key_test

;  ; player moving down uses fixed frame E_PLAYER_SPRITE_MOVE_DOWN
;  LD V4, E_PLAYER_SPRITE_MOVE_DOWN				; V4 = E_PLAYER_SPRITE_MOVE_DOWN
 
  ADD VC, V3							; player.ypos += player.const PLAYER_SPEED_Y

lbl_do_update_player_up_key_test:
  ; if (KEY_UP != pressed)
  ; then jump to switch end
  SKP V8
  JP lbl_do_update_player_key_test_end		

  SUB VC, V3							; player.ypos -= player.const PLAYER_SPEED_Y
 
lbl_do_update_player_key_test_end:

  JP lbl_do_update_player_switch_end				; break

lbl_do_update_player_switch_end:

  ; save all player info
  LDHI I, data_player_info-9
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateEnemies
;---------------------------------------------------------------------------------
func_DoUpdateEnemies:

  ; VC is enemy loop counter
  LD VC, 0							; VC = loop counter

  SPRW ENEMY_WIDTH
  SPRH ENEMY_HEIGHT

lbl_do_update_enemies_loop_start:

  ; load enemy info
  LDHI I, data_enemy_slot_lookup
  ADD I, VC
  LD V3, [I]
  LD I, lbl_do_update_enemies_ptr1
  LD [I], V3
  LD I, lbl_do_update_enemies_ptr2
  LD [I], V3

lbl_do_update_enemies_ptr1:
  LDHI I, lbl_do_update_enemies_ptr1

  LD VB, [I]
								; V5 = enemy.state
								; V6 = enemy.health
  								; V7 = enemy.timer
  								; V8 = enemy.xpos
								; V9 = enemy.ypos
								; VA = enemy.type
								; VB = enemy.move

  ; set up switch
  LDHI I, data_enemy_update_state_switch_lookup
  ADD I, V5
  LD V1, [I]
  LD I, lbl_do_update_enemies_switch_start
  LD [I], V1

lbl_do_update_enemies_switch_start:
  JP lbl_do_update_enemies_switch_start

lbl_do_update_enemies_case_damaged_by_laser:
 
  ; mark the enemy as damaged shield
  LD V5, E_ENEMY_STATE_DAMAGED_SHIELD_1				; enemy.state = E_ENEMY_STATE_DAMAGED_SHIELD_1
  
  LD V4, E_ENEMY_SPRITE_DAMAGED_0
  JP lbl_do_update_enemies_draw_alive

lbl_do_update_enemies_case_damaged_shield_1:
lbl_do_update_enemies_case_damaged_shield_2:
lbl_do_update_enemies_case_damaged_shield_3:

  ; mark the enemy as damaged shield
  ADD V5, #02							; enemy.state = E_ENEMY_STATE_DAMAGED_SHIELD++
  
  LD V4, E_ENEMY_SPRITE_DAMAGED_0
  JP lbl_do_update_enemies_draw_alive

lbl_do_update_enemies_case_damaged_shield_last:

  ; mark the enemy as alive again
  LD V5, E_ENEMY_STATE_ALIVE					; enemy.state = E_ENEMY_STATE_ALIVE

  ; fall through to alive
  
lbl_do_update_enemies_case_alive:
  
  LD V4, E_ENEMY_SPRITE_ALIVE_0
  
  ; fall through to draw alive

lbl_do_update_enemies_draw_alive:
								; V4 is either E_ENEMY_SPRITE_DAMAGED_0 + global.anim
  ADD V4, VE							; or E_ENEMY_SPRITE_ALIVE_0 + global.anim
  CALL func_DrawEnemy

  LDHI I, data_enemy_alive_constants-0
  LD V3, [I]
								; V0 = enemy.const ENEMY_ALIVE_X_MOVE_MASK
								; V1 = enemy.const ENEMY_ALIVE_Y_MOVE_MASK
								; V2 = enemy.const ENEMY_ALIVE_XPOS_MIN
								; V3 = enemy.const ENEMY_ALIVE_TIMER_MOVE_INC

  AND V0, VB
  SUB V8, V0							; enemy.xpos -= (enemy.move & enemy.const ENEMY_ALIVE_X_MASK)

  ; if (enemy.xpos <= enemy.const ENEMY_ALIVE_XPOS_MIN)
  ; then skip to dying_alive
  SUB V2, V8			
  SNE VF, 1							; VF = 1 if enemy.xpos <= enemy.const ENEMY_ALIVE_XPOS_MIN
  JP lbl_do_update_enemies_now_dead				

  ; else enemy is still alive

  ADD V7, V3							; enemy.timer += enemy.const ENEMY_ALIVE_TIMER_MOVE_INC

  AND V1, VB							
  LDHI I, data_enemy_y_movement_lookup
  ADD I, V1
  LD V3, [I]  
  LD I, lbl_do_update_enemies_ptr3
  LD [I], V3
lbl_do_update_enemies_ptr3:
  LDHI I, lbl_do_update_enemies_ptr3
  ADD I, V7
  LD V0, [I]
  ADD V9, V0							; enemy.ypos += delta[movement[enemy.move & enemy.const ENEMY_ALIVE_Y_MASK]]
  
  JP lbl_do_update_enemies_switch_end				; break

lbl_do_update_enemies_case_killed_by_laser:
 
  ; load game.score
  LDHI I, data_game_scoreinfo-0			
  LD V3, [I]						
								; V0 = game.score 100s
								; V1 = game.score 10s
								; V2 = game.score 1s
								; V3 = game.score
  ; increment
  ADD V3, GAME_SCORE_INC					; game.score++
  
  ; set BCD
  LD B, V3
  LDHI I, data_game_scoreinfo-0
  LD V2, [I]
  SHL V0
  SHL V0
  SHL V1
  SHL V1
  SHL V2
  SHL V2

  ; save updated game.score
  LD [I], V3

  ; fall through

lbl_do_update_enemies_case_hit_something:

  LD V5, E_ENEMY_STATE_DYING					; enemy.state = E_ENEMY_STATE_DYING
  LD V7, 0							; enemy.timer = 0

 ; fall through to dying

lbl_do_update_enemies_case_dying:

  ; enemy is dying
  LD V4, E_ENEMY_SPRITE_DYING_0
  ADD V4, V7							; V4 += enemy.timer
  CALL func_DrawEnemy

  ; load dying constants
  LDHI I, data_enemy_dying_constants-0
  LD V3, [I]	
								; V0 = enemy.const ENEMY_DYING_XPOS_MIN
								; V1 = enemy.const ENEMY_DYING_SPEED_X
								; V2 = enemy.const ENEMY_DYING_TIMER_INC 
								; V3 = enemy.const ENEMY_DYING_TIMER_MAX 

  ADD V7, V2							; enemy.timer += ENEMY_DYING_TIMER_INC

  ; if (enemy.timer == enemy.const ENEMY_DYING_TIMER_MAX)
  ; then enemy has died
  SNE V7, V3
  JP lbl_do_update_enemies_now_dead				

  SUB V8, V1							; enemy.xpos -= enemy.const ENEMY_DYING_SPEED_X

  ; if (enemy.xpos <= enemy.const ENEMY_DYING_XPOS_MIN)
  ; then skip to died
  SUB V0, V8			
  SNE VF, 1							; VF = 1 if enemy.xpos <= enemy.const ENEMY_DYING_XPOS_MIN
  JP lbl_do_update_enemies_now_dead

  ; else enemy is still dying

  JP lbl_do_update_enemies_switch_end				; break

lbl_do_update_enemies_now_dead:
				
  LD V5, E_ENEMY_STATE_DEAD					; enemy.state = E_ENEMY_STATE_DEAD

  JP lbl_do_update_enemies_switch_end				; break	

lbl_do_update_enemies_case_dead:

  ; empty 

  JP lbl_do_update_enemies_switch_end				; break

lbl_do_update_enemies_switch_end:

lbl_do_update_enemies_ptr2:
  LDHI I, lbl_do_update_enemies_ptr2
  ; save enemy
  LD [I], VB

lbl_do_update_enemies_loop_next:  
  
  ; if (loop == ENEMY_SLOT_MAX)
  ; then end test nicely
  ADD VC, ENEMY_SLOT_INC
  SE VC, E_ENEMY_SLOT_MAX
  JP lbl_do_update_enemies_loop_start

lbl_do_update_enemies_end:

  RET 
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateBoss
;---------------------------------------------------------------------------------
func_DoUpdateBoss:

  ; load boss info
  LDHI I, data_boss_info-8
  LD VC, [I]
								; V8 = boss.state
								; V9 = boss.health
								; VA = boss.timer
  								; VB = boss.xpos
  								; VC = boss.ypos

  ; set up switch
  LDHI I, data_boss_update_switch_lookup
  ADD I, V8
  LD V1, [I]
  LD I, lbl_do_boss_update_switch_start
  LD [I], V1

lbl_do_boss_update_switch_start:
  JP lbl_do_boss_update_switch_start

lbl_do_boss_update_case_damaged_by_laser:

  ; load damaged constants
  LDHI I, data_boss_damaged_constants-4
  LD V7, [I]
               							; V4 = E_BOSS_SPRITE_DAMAGED
             							; V5 = unused
              							; V6 = boss.const BOSS_DAMAGED_TIMER_INC
								; V7 = boss.const BOSS_DAMAGED_TIMER_MAX
 
  CALL func_DrawBossEye

  ADD VA, V6							; boss.timer += BOSS_DAMAGED_TIMER_INC

  ; if (boss.timer == boss.const BOSS_DAMAGED_TIMER_MAX)
  ; then boss is back to alive
  SNE VA, V7
  JP lbl_do_boss_update_now_alive

  ; else boss is still damaged
  
  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_blink:

  ; load blink constants
  LDHI I, data_boss_blink_constants-4
  LD V7, [I]
                						; V4 = E_BOSS_SPRITE_BLINK
               							; V5 = unused
    								; V6 = boss.const BOSS_BLINK_TIMER_INC
								; V7 = boss.const BOSS_BLINK_TIMER_MAX

  CALL func_DrawBossEye

  ADD VA, V6							; boss.timer += BOSS_BLINK_TIMER_INC

  ; if (boss.timer == boss.const BOSS_BLINK_TIMER_MAX)
  ; then boss is back to alive
  SNE VA, V7
  JP lbl_do_boss_update_now_alive

  ; else boss is still blinking

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_killed_by_laser:

  ; boss should start dying
  LD VA, 0							; boss.timer = 0
  LD V8, E_BOSS_STATE_DYING					; boss.state = E_BOSS_STATE_DYING
 
  ; player is now invulnerable
  LDHI I, data_player_info-0
  LD V0, E_PLAYER_STATE_INVULNERABLE
  LD [I], V0
   
  ; fall through to dying

lbl_do_boss_update_case_dying:

  ; load dying constants
  LDHI I, data_boss_dying_constants-4
  LD V7, [I]							; V4 = E_BOSS_SPRITE_DYING_0
								; V5 = unused
								; V6 = boss.const BOSS_DYING_TIMER_INC
								; V7 = boss.const BOSS_DYING_TIMER_MAX 

  ADD V4, VE							; V4 += boss.globalanim
  CALL func_DrawBossEye

  ADD VA, V6							; boss.timer += BOSS_DYING_TIMER_INC

  ; if (boss.timer == boss.const BOSS_DYING_TIMER_MAX)
  ; then boss has died
  SNE VA, V7
  JP lbl_do_boss_update_now_dead				
 
  ; else boss is still dying

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_now_dead:

  LD V8, E_BOSS_STATE_DEAD					; boss.state = E_BOSS_STATE_DEAD
 
  ; load game lives info
  LD I, data_game_livesinfo-0
  LD V3, [I]
								; V0 = game.lives
								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								; V2 = game.const GAME_LIVES_BOSS_SHIFT
								; V3 = game.const GAME_LIVES_WIN_SHIFT

  ADD V0, V3							; game.lives += GAME_LIVES_WIN_SHIFT

  ; save updated game lives info	
  LD [I], V3  

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_dead:

  ; empty

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_now_alive:

  LD V8, E_BOSS_STATE_ALIVE					; boss.state = E_BOSS_STATE_ALIVE  

  JP lbl_do_boss_update_switch_end  				; break

lbl_do_boss_update_case_alive:

  ; random chance to blink
  RND V0, BOSS_ALIVE_BLINK_CHANCE 
  SE V0, BOSS_ALIVE_BLINK_CHANCE
  JP lbl_do_boss_update_switch_end				; break

  ; do a blink
  LD VA, 0							; boss.timer = 0
  LD V8, E_BOSS_STATE_BLINK					; boss.state = E_BOSS_STATE_BLINK
  
  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_switch_end:

  ; save boss
  LDHI I, data_boss_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBackgroundAndParallax
;---------------------------------------------------------------------------------
func_DrawBackgroundAndParallax:

  SPRW BACKGROUND_WIDTH
  SPRH BACKGROUND_HEIGHT
  LDHI I, data_sprite_background

  LD V0, 0
  DRW V0, V0, 1

  SPRW PARALLAX_WIDTH
  SPRH PARALLAX_HEIGHT

  LDHI I, data_sprite_parallax_A
  LD V6, 8

  SNE VD, GAMEPLAY_GLOBALDATA_MAX
  JP lbl_use_parallax_A

  ; set xpos draw position
  LD V6, 64
  SUB V6, VE
  SHR V6
  SHR V6
  SHR V6							; V6 = (64 - global.anim) / 8

  LD V1, #01
  AND V1, VD
  SE V1, 1
  JP lbl_use_parallax_A

  LDHI I, data_sprite_parallax_B

lbl_use_parallax_A:  

  DRW V6, V0, 1

  RET
;---------------------------------------------------------------------------------


 
;---------------------------------------------------------------------------------
; func_DrawBorder
;---------------------------------------------------------------------------------
func_DrawBorder:

  SPRW BORDER_WIDTH
  SPRH BORDER_HEIGHT

  LDHI I, data_sprite_border
  LD V0, 0
  DRW V0, V0, 1

  LDHI I, data_game_scoreinfo-4
  LD VB, [I]
								; V4 = game.score 100s
								; V5 = game.score 10s
								; V6 = game.score 1s
								; V7 = game.score
								; V8 = game.const GAME_SCORE_Y_POS
								; V9 = game.const GAME_SCORE_100S_X_POS
								; VA = game.const GAME_SCORE_10S_X_POS
								; VB = game.const GAME_SCORE_1S_X_POS

  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_game_border_score_ptr1
  LD [I], V3
lbl_game_border_score_ptr1:
  LDHI I, lbl_game_border_score_ptr1
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_game_border_score_ptr2
  LD [I], V3
lbl_game_border_score_ptr2:
  LDHI I, lbl_game_border_score_ptr2
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_game_border_score_ptr3
  LD [I], V3
lbl_game_border_score_ptr3:
  LDHI I, lbl_game_border_score_ptr3
  DRW VB, V8, 1

  ; draw lives
  LDHI I, data_game_livesinfo-6
  LD VB, [I]
								; V6 = game.lives
								; V7 = game.const GAME_LIVES_GAMEPLAY_MASK
								; V8 = game.const GAME_LIVES_BOSS_SHIFT
								; V9 = game.const GAME_LIVES_WIN_SHIFT
								; VA = game.const GAME_LIVES_Y_POS
								; VB = game.const GAME_LIVES_X_POS

  LDHI I, data_draw_border_lives_switch_lookup
  ADD I, V6 
  LD V1, [I]
  LD I, lbl_draw_border_lives_switch_start
  LD [I], V1

lbl_draw_border_lives_switch_start:
  JP lbl_draw_border_lives_switch_start

lbl_draw_border_lives_case_lives_3:
lbl_draw_border_lives_case_lives_3_boss:

  LDHI I, data_sprite_number_2
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_lives_2:
lbl_draw_border_lives_case_lives_2_boss:

  LDHI I, data_sprite_number_1
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_lives_1:
lbl_draw_border_lives_case_lives_1_boss:

  LDHI I, data_sprite_number_0
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_game_over:
lbl_draw_border_lives_case_start_screen:
lbl_draw_border_lives_case_lives_1_win:
lbl_draw_border_lives_case_lives_2_win:
lbl_draw_border_lives_case_lives_3_win:
lbl_draw_border_lives_case_null:

  ; empty

lbl_draw_border_lives_switch_end:

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawPlayer
; Draws player sprite index V4 at position [VB, VC]
;---------------------------------------------------------------------------------
func_DrawPlayer:
  
  SPRW PLAYER_WIDTH
  SPRH PLAYER_HEIGHT

  ; player info must be loaded before func_DrawPlayer is called!
  								; V4 = player sprite
  								; VB = player x-position
  								; VC = player y-position
  LDHI I, data_player_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_player_ptr		
  LD [I], V3		
lbl_draw_player_ptr:
  LDHI I, lbl_draw_player_ptr  

  ; draw player sprite
  DRW VB, VC, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawLaser
; Draws laser sprite index V4 at position [VB, VC]
;---------------------------------------------------------------------------------
func_DrawLaser:
  
  SPRW LASER_WIDTH
  SPRH LASER_HEIGHT

  ; laser info must be loaded before func_DrawLaser is called!
  								; V4 = laser sprite
  								; VB = laser x-position
  								; VC = laser y-position

  LDHI I, data_laser_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_laser_ptr		
  LD [I], V3		
lbl_draw_laser_ptr:
  LDHI I, lbl_draw_laser_ptr  

  ; draw laser sprite
  DRW VB, VC, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBullet
; Draws bullet sprite index V4 at position [V9, VA]
;---------------------------------------------------------------------------------
func_DrawBullet:

  ; bullet info must be loaded before func_DrawBullet is called!
  ; Also make sure SPRW and SPRH have been set correctly!
  								; V4 = bullet sprite
  								; V9 = bullet x-position
  								; VA = bullet y-position
  
  LDHI I, data_bullet_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_bullet_sprite_ptr		
  LD [I], V3		
lbl_draw_bullet_sprite_ptr:
  LDHI I, lbl_draw_bullet_sprite_ptr  

  ; draw bullet sprite
  DRW V9, VA, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawEnemy
; Draws enemy type VA sprite index V4 at position [V8, V9]
;---------------------------------------------------------------------------------
func_DrawEnemy:
  
  ; enemy info must be loaded before func_DrawEnemy is called!
  ; Also make sure SPRW and SPRH have been set correctly!
  								; V4 = enemy sprite
  								; V8 = enemy x-position
  								; V9 = enemy y-position
  								; VA = enemy type

  ; use enemy.type V9 to set the correct sprite lookup table
  LDHI I, data_enemy_type_lookup
  ADD I, VA
  LD V3, [I]
  LD I, lbl_draw_enemy_lookup_ptr				
  LD [I], V3
lbl_draw_enemy_lookup_ptr:
  LDHI I, lbl_draw_enemy_lookup_ptr
  
  ; and use V4 to draw correct sprite frame
  ADD I, V4
  LD V3, [I]
  LD I, lbl_draw_enemy_sprite_ptr		
  LD [I], V3		
lbl_draw_enemy_sprite_ptr:
  LDHI I, lbl_draw_enemy_sprite_ptr  

  ; draw enemy sprite
  DRW V8, V9, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBossEye
; Draws boss eye sprite index V4 at position [VB, VC]
;---------------------------------------------------------------------------------
func_DrawBossEye:
  
  SPRW BOSS_WIDTH
  SPRH BOSS_HEIGHT

  ; boss info must be loaded before func_DrawBossEye is called!
  								; V4 = boss eye sprite
  								; VB = boss x-position
  								; VC = boss y-position

  LDHI I, data_boss_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_boss_ptr		
  LD [I], V3		
lbl_draw_boss_ptr:
  LDHI I, lbl_draw_boss_ptr  

  ; draw boss sprite
  DRW VB, VC, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawCollisionWalls
; Draws the upper and lower boundary collision walls.
;---------------------------------------------------------------------------------
func_DrawCollisionWalls:

  SPRW WALL_STRIP_WIDTH
  SPRH WALL_STRIP_HEIGHT
  
;  LD V4, VD							; V4 = global.data
  LD V4, 0
  
  LD V5, V4							; V5 = V4 + 15. 
  ADD V5, 15				
  
  ; set xpos draw position
  LD V6, GAMEPLAY_GLOBALANIM_MAX
  SUB V6, VE
  SHR V6
  SHR V6							; V6 = (64 - global.anim) / 4
  
  ; set ypos draw position
  LD V7, WALL_YPOS						; V7 = Wall tile ypos draw position. Never changes.

lbl_draw_collision_walls_loop:

  ; get wall tile index from tile data map
  LDHI I, data_walls_map  
  ADD I, V4							; add tile data offset
  LD V0, [I]
 
  ; get collsion wall sprite from wall collision tile lookup
  LDHI I, data_walls_collision_lookup
  ADD I, V0
  LD V3, [I]
  LD I, lbl_draw_collision_walls_ptr
  LD [I], V3
lbl_draw_collision_walls_ptr:
  LDHI I, lbl_draw_collision_walls_ptr

  ; draw collision wall sprite
  DRW V6, V7, 1
 
  ADD V4, 1							; wall data++
  ADD V6, 16							; wall xpos += 16
  
  ; if still more walls to draw, goto start of loop
  SE V4, V5
  JP lbl_draw_collision_walls_loop

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawRealWalls
; Draws the real upper and lower boundary walls.
;---------------------------------------------------------------------------------
func_DrawRealWalls:

  SPRW WALL_STRIP_WIDTH
  SPRH WALL_STRIP_HEIGHT
  
;  LD V4, VD							; V4 = global.data
  LD V4, 0
  
  LD V5, V4							; V5 = V4 + 15
  ADD V5, 15				
  
  ; set xpos draw position
  LD V6, GAMEPLAY_GLOBALANIM_MAX
  SUB V6, VE
  SHR V6
  SHR V6							; V6 = (64 - global.anim) / 4
  
  ; set ypos draw position
  LD V7, WALL_YPOS						; V7 = Wall tile ypos draw position. Never changes.

lbl_draw_real_walls_loop:

  ; get wall tile index from tile data map
  LDHI I, data_walls_map  
  ADD I, V4							; add tile data offset
  LD V0, [I]
 
  ; get real wall sprite from wall real tile lookup
  LDHI I, data_walls_strip_lookup
  ADD I, V0
  LD V3, [I]
  LD I, lbl_draw_real_walls_ptr
  LD [I], V3
lbl_draw_real_walls_ptr:
  LDHI I, lbl_draw_real_walls_ptr

  ; draw real wall sprite
  DRW V6, V7, 1
 
  ADD V4, 1							; wall data++
  ADD V6, 16							; wall xpos += 16
  
  ; if still more walls to draw, goto start of loop
  SE V4, V5
  JP lbl_draw_real_walls_loop

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; END OF CODE
;---------------------------------------------------------------------------------
lbl_end_code:
  LD I, lbl_end_code
  DA 'Code, art and other assets copyright Michael Neve 2012. /)*(\'

;---------------------------------------------------------------------------------
; GAME INFO
;---------------------------------------------------------------------------------
INCLUDE 'gameinfo.src'

;---------------------------------------------------------------------------------
; PLAYER INFO
;---------------------------------------------------------------------------------
INCLUDE 'playerinfo.src'

;---------------------------------------------------------------------------------
; LASER INFO
;---------------------------------------------------------------------------------
INCLUDE 'laserinfo.src'

;---------------------------------------------------------------------------------
; ENEMY INFO
;---------------------------------------------------------------------------------
;INCLUDE 'enemyinfo.src'
INCLUDE 'enemy_movement.src'
INCLUDE 'boss.src'

;---------------------------------------------------------------------------------
; BULLET INFO
;---------------------------------------------------------------------------------
;INCLUDE 'bulletinfo.src'
INCLUDE 'bullet_movement.src' 

;---------------------------------------------------------------------------------
; WALL INFO
;---------------------------------------------------------------------------------
INCLUDE 'wallinfo.src'

;---------------------------------------------------------------------------------
; GENERIC
;---------------------------------------------------------------------------------

