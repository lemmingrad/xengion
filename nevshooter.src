;---------------------------------------------------------------------------------
; NevShooter copyright Michael Neve 2012
; No, it has nothing to do with shooting me.
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; A note on register usage, for in-game and boss states:
;
;   VF = Reserved for carry/collision. Do not use.
; 
;   Gameplay state:
;   VE = Global anim counter. Loops continuously from 0 to GAME_GLOBALANIM_MAX, step GAME_GLOBALANIM_INC. (global.anim)
;   VD = Data index. Increments by GAME_GLOBALDATA_INC each time VE rolls around, up to GAME_GLOBALDATA_MAX. (global.data)
;
;   VD and VE may have different uses in title/gameplay/boss/game-over states
;---------------------------------------------------------------------------------

  MEGAON							; Megachip8 mode

  LDHI I, data_palette						; Load a palette
  LDPAL PALETTE_SIZE

lbl_main_frame_loop_start:
  
  CLS

  ; load game info
  ; It has the game state (aka number of lives).
  LDHI I, data_game_livesinfo-0
  LD V0, [I]
								; V0 = game.lives

  ; if (game.lives == E_GAME_LIVES_START_SCREEN)
  ; then do title screen
  ; else if (game.lives == E_GAME_LIVES_GAME_OVER)
  ; then do game-over screen
  ; else if (game.lives == E_GAME_LIVES_X)
  ; then do gameplay
  ; else if (game.lives == E_GAME_LIVES_X_BOSS)
  ; then do boss
  ; else if (game.lives == E_GAME_LIVES_X_WIN)
  ; then do win screen

  LDHI I, data_game_main_frame_lives_switch_lookup
  ADD I, V0
  LD V1, [I]
  LD I, lbl_main_frame_lives_switch_start
  LD [I], V1

lbl_main_frame_lives_switch_start:
  JP lbl_main_frame_lives_switch_start

lbl_main_frame_lives_case_start_screen:

  CALL func_DoTitleScreen

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1:
lbl_main_frame_lives_case_lives_2:
lbl_main_frame_lives_case_lives_3:

  CALL func_DoGameplay

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1_boss:
lbl_main_frame_lives_case_lives_2_boss:
lbl_main_frame_lives_case_lives_3_boss:

  CALL func_DoBossplay

  JP lbl_main_frame_lives_switch_end				; break

lbl_main_frame_lives_case_lives_1_win:
lbl_main_frame_lives_case_lives_2_win:
lbl_main_frame_lives_case_lives_3_win:
lbl_main_frame_lives_case_game_over:

  CALL func_DoGameOverScreen

  JP lbl_main_frame_lives_switch_end

lbl_main_frame_lives_case_null:

  ; empty

lbl_main_frame_lives_switch_end:

  ; loop to start
  JP lbl_main_frame_loop_start

  EXIT								; should never reach here
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoTitleScreen
;---------------------------------------------------------------------------------
func_DoTitleScreen:

  ; draw title screen sprite
  SPRW TITLE_SCREEN_WIDTH
  SPRH TITLE_SCREEN_HEIGHT
  LDHI I, data_sprite_title_screen
  LD V0, 0
  DRW V0, V0, 1

  ; increment a title screen timer				; VD = gametitle.timer
  SE VD, GAMETITLE_TIMER_MAX
  ADD VD, GAMETITLE_TIMER_INC

  ; load game data 
  LDHI I, data_game_hiscoreinfo-5
  LD VC, [I]
								; V5 = game.hi-score 100s
								; V6 = game.hi-score 10s
								; V7 = game.hi-score 1s
								; V8 = game.hi-score
								; V9 = game.const GAME_HISCORE_Y_POS
								; VA = game.const GAME_HISCORE_100S_X_POS
								; VB = game.const GAME_HISCORE_10S_X_POS
								; VC = game.const GAME_HISCORE_1S_X_POS


  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; draw hi-score 100s
  LD I, lbl_game_start_screen_ptr1+2
  LD V0, V5
  LD [I], V0
lbl_game_start_screen_ptr1:
  LDHI I, data_interleaved_aligned
  DRW VA, V9, 1

  ; draw hi-score 10s
  LD I, lbl_game_start_screen_ptr2+2
  LD V0, V6
  LD [I], V0
lbl_game_start_screen_ptr2:
  LDHI I, data_interleaved_aligned
  DRW VB, V9, 1

  ; draw hi-score 1s
  LD I, lbl_game_start_screen_ptr3+2
  LD V0, V7
  LD [I], V0
lbl_game_start_screen_ptr3:
  LDHI I, data_interleaved_aligned
  DRW VC, V9, 1

  ; if gametitle.timer < GAMETITLE_TIMER_ALLOW_CONTINUE
  ; then return
  LD V0, GAMETITLE_TIMER_ALLOW_CONTINUE
  SUB V0, VD
  SE VF, 0
  RET

  ; if (KEY_START != pressed)
  ; then return
  LD V0, KEY_START
  SKP V0				
  RET

  ; Begin transition into gameplay state
  ; reset lives
  LDHI I, data_game_livesinfo-0
  LD V0, E_GAME_LIVES_3						; game.lives = E_GAME_LIVES_3
  LD [I], V0

  ; reset score
  LDHI I, data_game_scoreinfo-0
  LD V0, 0							; game.score 100s = 0
  LD V1, 0							; game.score 10s = 0
  LD V2, 0							; game.score 1s = 0
  LD V3, 0							; game.score = 0
  LD [I], V3

  ; reset everything else
  CALL func_ResetGameplay

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_ResetGameplay
;---------------------------------------------------------------------------------
func_ResetGameplay:

  ; reset global.data
  LD VD, 0

  ; reset global.anim
  LD VE, 0 

  ; load enemy threats
  LD V0, E_ENEMY_STATE_DEAD
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_0
  LD [I], V0
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_1
  LD [I], V0
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_2
  LD [I], V0
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_3
  LD [I], V0
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_4
  LD [I], V0

  CALL func_LoadGameplayEnemyThreats
  
  ; load bullet threats
  LD V0, E_BULLET_STATE_DEAD
  LDHI I, data_bullet_slots + E_BULLET_SLOT_0
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_1
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_2
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_3
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_4
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_5
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_6
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_7
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_8
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_9
  LD [I], V0

  LDHI I, data_gameplay_bulletthreat_lookup
  CALL func_LoadBulletThreats

  ; reset laser
  LDHI I, data_laser_reset
  LD V4, [I]
  LDHI I, data_laser_info
  LD [I], V4
 
  ; reset player
  LDHI I, data_player_reset
  LD V3, [I]
  LDHI I, data_player_info
  LD [I], V3
  
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoGameplay
;---------------------------------------------------------------------------------
func_DoGameplay:

  CALL func_DrawBackgroundAndParallax
  CALL func_DrawCollisionWalls
  CALL func_DoPlayerVsWalls

  ; draw laser collision in purple, test for collision against walls (orange)
  CALL func_DoLaserVsWalls

  ; draw enemies collision in green, test for collision against walls (orange), player (also orange) or laser (purple)
  CALL func_DoEnemiesVsMultiCol

  ; draw player collision in orange, test for collision against enemies (green)
;  CALL func_DoPlayerVsEnemies

  ; do bullet logic
  CALL func_DoUpdateBullets

  CALL func_DrawRealWalls

  CALL func_DoPlayerVsBullets

  ; update and draw laser
  CALL func_DoUpdateLaser
   
  ; update and draw enemies
  CALL func_DoUpdateEnemies

  CALL func_DoUpdatePlayerForGameplay
  
  ; Do special flow control for gameplay state
  ; player.state is already loaded in V9

lbl_do_gameplay_test_prev:

  SE V9, E_PLAYER_STATE_MODE_PREV
  JP lbl_do_gameplay_test_next

  CALL func_ResetGameplay
  
  ; decrement game.lives
  LD I, data_game_livesinfo-0				 
  LD V1, [I]
								; V0 = game.lives
  								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								
  AND V0, V1							; game.lives &= GAME_LIVES_GAMEPLAY_MASK
  ADD V0, GAME_LIVES_DEC 					; game.lives--
  LD [I], V0

  CALL func_DrawBorder

  RET

lbl_do_gameplay_test_next:

  SE V9, E_PLAYER_STATE_MODE_NEXT
  JP lbl_do_gameplay_test_end

  CALL func_ResetBossplay

  ; update lives
  LD I, data_game_livesinfo-0				 
  LD V2, [I]
								; V0 = game.lives
								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								; V2 = game.const GAME_LIVES_BOSS_SHIFT
  ADD V0, V2							; game.lives += GAME_LIVES_BOSS_SHIFT
  LD [I], V0

  CALL func_DrawBorder

  RET

lbl_do_gameplay_test_end:
  
;  CALL func_DrawBorder

  ; increment anim counter
  ADD VE, GAMEPLAY_GLOBALANIM_INC				; global.anim++

  ; if (global.anim != 64)
  ; then early exit 
  SE VE, GAMEPLAY_GLOBALANIM_MAX
  RET
  
  LD VE, 0							; global.anim = 0
  
  ; global.data controls the wallinfo and all gameplay threats
  ; During normal gameplay, it doesn't want to pass ~240, because the last screen should be for player outro 
  ; if (global.data == GAMEPLAY_GLOBALDATA_MAX)
  ; then early exit
  SNE VD, GAMEPLAY_GLOBALDATA_MAX
  RET

  ADD VD, GAMEPLAY_GLOBALDATA_INC				; global.data++

  ; load any new enemies or bullets
  CALL func_LoadGameplayEnemyThreats

  LDHI I, data_gameplay_bulletthreat_lookup
  CALL func_LoadBulletThreats

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_LoadGameplayEnemyThreats
;---------------------------------------------------------------------------------
func_LoadGameplayEnemyThreats

  LDHI I, data_gameplay_enemythreat_lookup
  ADD I, VD
  LD V0, [I]

  ; if no enemy threat
  ; then early return
  SNE V0, E_NO_ENEMY_THREAT										
  RET			

  ; else there is an enemy threat
 
  LDHI I, data_enemy_threats-9
  ADD I, V0
  LD VC, [I]
								; V9 = enemythreat.enemytemplate
								; VA = enemythreat.slot
								; VB = enemythreat.ypos
								; VC = enemythreat.move
  ; load enemy template
  LDHI I, data_enemy_templates-2
  ADD I, V9
  LD V8, [I]
  								; V2 = enemy.state
								; V3 = enemy.health
								; V4 = enemy.timer
								; V5 = enemy.xpos
								; V6 = enemy.ypos
								; V7 = enemy.type
								; V8 = enemy.move

  ; overwrite template with values
  LD V6, VB							; enemy.ypos = enemythreat.ypos
  LD V8, VC							; enemy.move = enemythreat.move

  ; save enemy
  LDHI I, data_enemy_slots-2
  ADD I, VA
  LD [I], V8
  
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_ResetBossplay
;---------------------------------------------------------------------------------
func_ResetBossplay:

  ; reset global.data
  LD VD, 0

  ; reset global.anim
  LD VE, 0 

  ; load enemy threats
  LDHI I, data_enemy_bossturrets + E_ENEMY_SLOT_0
  LD VC, [I]
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_0
  LD [I], VC
  LDHI I, data_enemy_bossturrets + E_ENEMY_SLOT_1
  LD VC, [I]
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_1
  LD [I], VC
  LDHI I, data_enemy_bossturrets + E_ENEMY_SLOT_2 
  LD VC, [I]
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_2
  LD [I], VC
  LDHI I, data_enemy_bossturrets + E_ENEMY_SLOT_3
  LD VC, [I]
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_3
  LD [I], VC
  LDHI I, data_enemy_bossturrets + E_ENEMY_SLOT_4
  LD VC, [I]
  LDHI I, data_enemy_slots + E_ENEMY_SLOT_4
  LD [I], VC

  ; load bullet threats
  LD V0, E_BULLET_STATE_DEAD
  LDHI I, data_bullet_slots + E_BULLET_SLOT_0
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_1
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_2
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_3
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_4
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_5
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_6
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_7
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_8
  LD [I], V0
  LDHI I, data_bullet_slots + E_BULLET_SLOT_9
  LD [I], V0

  LDHI I, data_bossplay_bulletthreat_lookup
  CALL func_LoadBulletThreats

  ; reset boss
  LDHI I, data_boss_reset
  LD V4, [I]
  LDHI I, data_boss_info
  LD [I], V4

  ; reset laser
  LDHI I, data_laser_reset
  LD V4, [I]
  LDHI I, data_laser_info
  LD [I], V4
 
  ; reset player
  LDHI I, data_player_reset
  LD V3, [I]
  LDHI I, data_player_info
  LD [I], V3

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoBossplay
;---------------------------------------------------------------------------------
func_DoBossplay:

  ; draw background and collision walls in orange
  LDHI I, data_sprite_boss_background_col
  SPRW BOSS_BACKGROUND_WIDTH
  SPRH BOSS_BACKGROUND_HEIGHT
  LD V0, 0
  DRW V0, V0, 1

  ; draw player collision in orange, test for collision against walls (orange)
  CALL func_DoPlayerVsWalls  
 
  ; draw laser collision in purple, test for collision against walls (orange)
  CALL func_DoLaserVsWalls

  ; draw boss collision in green, test against laser (purple)
  CALL func_DoBossVsLaser

  ; draw enemies collision in green, test for collision against walls (orange), player (also orange) or laser (purple)
  CALL func_DoEnemiesVsMultiCol

  ; draw player collision in orange, test for collision against enemies (green), which will include boss
  CALL func_DoPlayerVsEnemies

  ; do bullet logic
  CALL func_DoUpdateBullets

  ; draw walls
  LDHI I, data_sprite_boss_background
  SPRW BOSS_BACKGROUND_WIDTH
  SPRH BOSS_BACKGROUND_HEIGHT
  LD V0, 0
  DRW V0, V0, 1
 
;  CALL func_DoPlayerVsBullets
  
  ; update and draw laser
  CALL func_DoUpdateLaser
  
  ; update and draw boss
  CALL func_DoUpdateBoss
  
  ; update and draw enemies
  CALL func_DoUpdateEnemies
  
  ; update and draw player
  CALL func_DoUpdatePlayerForBossplay

  ; Do special flow control for bossplay state
  ; player.state is already loaded in V9

lbl_do_bossplay_test_prev:

  SE V9, E_PLAYER_STATE_MODE_PREV
  JP lbl_do_bossplay_test_next

  CALL func_ResetGameplay
  
  ; decrement game.lives
  LD I, data_game_livesinfo-0				 
  LD V1, [I]
								; V0 = game.lives
  								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								
  AND V0, V1							; game.lives &= GAME_LIVES_GAMEPLAY_MASK
  ADD V0, GAME_LIVES_DEC 					; game.lives--
  LD [I], V0

  CALL func_DrawBorder

  RET

lbl_do_bossplay_test_next:

  SE V9, E_PLAYER_STATE_MODE_NEXT
  JP lbl_do_bossplay_test_end

  ; update lives
  LD I, data_game_livesinfo-0
  LD V3, [I]
 								; V0 = game.lives
								; V1 = game.const GAME_LIVES_GAMEPLAY_MASK
								; V2 = game.const GAME_LIVES_BOSS_SHIFT
								; V3 = game.const GAME_LIVES_WIN_SHIFT

  ADD V0, V3							; game.lives += GAME_LIVES_WIN_SHIFT

  ; save updated game lives info	
  LD [I], V3  

  LD VD, 0
  LD VE, 0

  CALL func_DrawBorder

  RET

lbl_do_bossplay_test_end:

  ; draw score and border overlay
  CALL func_DrawBorder

  ; increment anim counter
  ADD VE, GAMEPLAY_GLOBALANIM_INC				; global.anim++

  ; if (global.anim != 64)
  ; then early exit 
  SE VE, GAMEPLAY_GLOBALANIM_MAX
  RET
 
  LD VE, 0							; global.anim = 0
  
  ; global.data controls the boss bullets
  ADD VD, GAMEPLAY_GLOBALDATA_INC				; global.data++

  ; load any new boss bullet threats
  LDHI I, data_bossplay_bulletthreat_lookup
  CALL func_LoadBulletThreats

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_LoadBulletThreats
;---------------------------------------------------------------------------------
func_LoadBulletThreats:

  ADD I, VD							; load threat for global.data position.
  LD V0, [I]

  ; if no bullet threat
  ; then early return
  SNE V0, E_NO_BULLET_THREAT										
  RET			

  ; else there is a bullet threat
 
  LDHI I, data_bullet_threats-11
  ADD I, V0
  LD VC, [I]
								; VB = bulletthreat.enemyslot
								; VC = bulletthreat.move

  ; VB is the owner of the bullet. Is the owner alive?
  LDHI I, data_enemy_slots-5
  ADD I, VB
  LD V9, [I]
								; V5 = enemy.state
								; V6 = enemy.health
								; V7 = enemy.timer
								; V8 = enemy.xpos
								; V9 = enemy.ypos
 
  ; if enemy != alive
  ; then early return
  SE V5, E_ENEMY_STATE_ALIVE
  RET

  ; else bullet owner enemy is alive

  LDHI I, data_bullet_template-3
  LD V7, [I]
								; V3 = template bullet.state
								; V4 = template bullet.timer
								; V5 = template bullet.xpos
								; V6 = template bullet.ypos
								; V7 = template bullet.move

  ADD V5, V8							; bullet.xpos += enemy.xpos
  ADD V6, V9							; bullet.ypos += enemy.ypos
  LD V7, VC							; bullet.move = bulletthreat.move
 
  LD VA, VB							; bullet slot = enemy slot * 2
  SHL VA
  LDHI I, data_bullet_slots
  ADD I, VA
  LD V0, [I]
  SE V0, E_BULLET_STATE_DEAD					; if bullet slot in use, go to the next one
  ADD VA, SIZEOF_BULLET

  ; save new bullet info
  LDHI I, data_bullet_slots-3
  ADD I, VA
  LD [I], V7

  ; bullet slot has been updated!

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoGameOverScreen
;---------------------------------------------------------------------------------
func_DoGameOverScreen:

  LDHI I, data_sprite_game_over_screen
  
  LD VE, 0							; VE = cumulative totalscore
  
  ; Draw game over screen sprite
  SPRW GAME_OVER_SCREEN_WIDTH
  SPRH GAME_OVER_SCREEN_HEIGHT
  DRW VE, VE, 1

  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; increment a game over screen timer				; VD = game.gameovertimer
  SE VD, GAMEOVER_SCREEN_TIMER_MAX
  ADD VD, GAMEOVER_SCREEN_TIMER_INC

  LDHI I, data_gameover_screen_enemies_display-8

  LD VC, [I]
								; V8 = game.const GAMEOVER_ENEMIES_Y_POS
 								; V9 = game.const GAMEOVER_ENEMIES_100S_X_POS
								; VA = game.const GAMEOVER_ENEMIES_10S_X_POS
								; VB = game.const GAMEOVER_ENEMIES_1S_X_POS
								; VC = game.const GAMEOVER_TIMER_ENEMIES

  ; if game.gameovertimer < GAMEOVER_TIMER_ENEMIES
  ; then skip to drawing current totalscore
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  ; draw enemies count

; TODO - OPTIMISE ALIGNED 16x16
  LDHI I, data_game_scoreinfo-4
  LD V7, [I]
								; V4 = game.score 100s
								; V5 = game.score 10s
								; V6 = game.score 1s
								; V7 = game.score  

  LD VE, V7							; totalscore = game.score

  ; draw enemies 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr1
  LD [I], V3
lbl_gameover_enemies_ptr1:
  LDHI I, lbl_gameover_enemies_ptr1
  DRW V9, V8, 1

  ; draw enemies 10s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr2
  LD [I], V3
lbl_gameover_enemies_ptr2:
  LDHI I, lbl_gameover_enemies_ptr2
  DRW VA, V8, 1

  ; draw enemies 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_enemies_ptr3
  LD [I], V3
lbl_gameover_enemies_ptr3:
  LDHI I, lbl_gameover_enemies_ptr3
  DRW VB, V8, 1

  ; draw boss and lives counters	

  LDHI I, data_gameover_screen_bosslives-7
  LD VC, [I]
								; V7 = game.const GAMEOVER_LIVES_Y_POS
  								; V8 = game.const GAMEOVER_LIVES_X_POS
 								; V9 = game.const GAMEOVER_BOSS_Y_POS
 								; VA = game.const GAMEOVER_BOSS_X_POS
 								; VB = game.const GAMEOVER_TIMER_LIVES
 								; VC = game.const GAMEOVER_TIMER_BOSS

  ; if game.gameovertimer < GAMEOVER_TIMER_BOSS
  ; then skip to drawing current totalscore
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_game_livesinfo-0
  LD V0, [I]
								; V0 = game.lives

  LDHI I, data_gameover_screen_lives_switch_lookup
  ADD I, V0
  LD V1, [I]
  LD I, lbl_gameover_lives_switch_start
  LD [I], V1

lbl_gameover_lives_switch_start:
  JP lbl_gameover_lives_switch_start

lbl_gameover_lives_case_game_over:

  LDHI I, data_sprite_number_0
  DRW VA, V9, 1
  
  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  DRW V8, V7, 1

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_1_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_0_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_1
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_1_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_2_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_0_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_2
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_2_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_lives_3_win:

  LDHI I, data_sprite_number_1
  DRW VA, V9, 1

  ADD VE, GAMEOVER_BOSSLIVES_0_TOTALSCORE_INC

  ; if game.gameovertimer < GAMEOVER_TIMER_LIVES
  ; then skip to drawing current totalscore
  SUB VB, VD
  SE VF, 0
  JP lbl_gameover_totalscore_ptr1

  LDHI I, data_sprite_number_3
  DRW V8, V7, 1
  
  ADD VE, GAMEOVER_BOSSLIVES_3_TOTALSCORE_INC

  JP lbl_gameover_lives_switch_end				; break

lbl_gameover_lives_case_start_screen:
lbl_gameover_lives_case_lives_1:
lbl_gameover_lives_case_lives_2:
lbl_gameover_lives_case_lives_3:
lbl_gameover_lives_case_lives_1_boss:
lbl_gameover_lives_case_lives_2_boss:
lbl_gameover_lives_case_lives_3_boss:
lbl_gameover_lives_case_null:

  ; empty

lbl_gameover_lives_switch_end:

lbl_gameover_totalscore_ptr1:

  ; draw total score
  LDHI I, data_gameover_screen_score_display-0			
  ; set BCD
  LD B, VE
  
  LDHI I, data_gameover_screen_score_display-5
  LD VC, [I]
								; V5 = reserved for game.resultscore 100s
  								; V6 = reserved for game.resultscore 10s
  								; V7 = reserved for game.resultscore 1s
								; V8 = game.const GAMEOVER_SCORE_Y_POS
  								; V9 = game.const GAMEOVER_SCORE_100S_X_POS
  								; VA = game.const GAMEOVER_SCORE_10S_X_POS
  								; VB = game.const GAMEOVER_SCORE_1S_X_POS
  								; VC = game.const GAMEOVER_TIMER_TOTALSCORE

  SHL V5
  SHL V5
  SHL V6
  SHL V6
  SHL V7
  SHL V7

  LD [I], V7

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr2
  LD [I], V3
lbl_gameover_totalscore_ptr2:
  LDHI I, lbl_gameover_totalscore_ptr2
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr3
  LD [I], V3
lbl_gameover_totalscore_ptr3:
  LDHI I, lbl_gameover_totalscore_ptr3
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V7
  LD V3, [I]
  LD I, lbl_gameover_totalscore_ptr4
  LD [I], V3
lbl_gameover_totalscore_ptr4:
  LDHI I, lbl_gameover_totalscore_ptr4
  DRW VB, V8, 1

  ; draw hi-score
  LDHI I, data_gameover_screen_hiscore_display-8
  LD VC, [I]
								; V8 = game.const GAMEOVER_HISCORE_Y_POS
  								; V9 = game.const GAMEOVER_HISCORE_100S_X_POS
							  	; VA = game.const GAMEOVER_HISCORE_10S_X_POS
								; VB = game.const GAMEOVER_HISCORE_1S_X_POS
								; VC = game.const GAMEOVER_TIMER_HISCORE

  LDHI I, data_game_hiscoreinfo-4
  LD V7, [I]
								; V4 = current game.hi-score 100s
								; V5 = current game.hi-score 10s
								; V6 = current game.hi-score 1s
								; V7 = current game.hi-score
  
  ; if game.gameovertimer < game.const GAMEOVER_TIMER_HISCORE
  ; then skip to drawing current hi-score
  SUB VC, VD
  SE VF, 0
  JP lbl_gameover_hiscore_ptr1

  ; if totalscore < hi-score
  ; then jump to pressed start test
  SUB V7, VE
  SE VF, 0
  JP lbl_gameover_press_start

  LD V7, VE							; new game.hi-score = totalscore

  LDHI I, data_gameover_screen_score_display-4
  LD V6, [I]
								; V4 = new game.hi-score 100s = game.resultscore 100s
								; V5 = new game.hi-score 10s = game.resultscore 10s
								; V6 = new game.hi-score 1s = game.resultscore 1s

  ; save new hi-score
  LDHI I, data_game_hiscoreinfo-4
  LD [I], V7

lbl_gameover_press_start:

  ; if (KEY_START != pressed)
  ; then return
  LD V0, KEY_START
  SKP V0				
  JP lbl_gameover_hiscore_ptr1

  ; go to title screen
  LDHI I, data_game_livesinfo-0
  LD V0, E_GAME_LIVES_START_SCREEN				; game.lives = E_GAME_LIVES_TITLE_SCREEN
  LD [I], V0
  LD VD, 0
  LD VE, 0

  RET

lbl_gameover_hiscore_ptr1:

; TODO - OPTIMISE ALIGN 16x16

  ; draw score 100s
  LDHI I, data_number_lookup
  ADD I, V4
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr2
  LD [I], V3
lbl_gameover_hiscore_ptr2:
  LDHI I, lbl_gameover_hiscore_ptr2
  DRW V9, V8, 1

  ; draw score 10s
  LDHI I, data_number_lookup  
  ADD I, V5
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr3
  LD [I], V3
lbl_gameover_hiscore_ptr3:
  LDHI I, lbl_gameover_hiscore_ptr3
  DRW VA, V8, 1

  ; draw score 1s
  LDHI I, data_number_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_gameover_hiscore_ptr4
  LD [I], V3
lbl_gameover_hiscore_ptr4:
  LDHI I, lbl_gameover_hiscore_ptr4
  DRW VB, V8, 1

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoLaserVsWalls
; Test laser collision against walls
;---------------------------------------------------------------------------------
func_DoLaserVsWalls:

  ; collision walls should have already been drawn in orange

  ; load laser
  LDHI I, data_laser_info-8
  LD VC, [I]
								; V8 = laser.state
								; V9 = laser.charge
								; VA = laser.timer
								; VB = laser.xpos
								; VC = laser.ypos

  ; if (laser.state != alive)
  ; then early return
  SE V8, E_LASER_STATE_ALIVE
  RET

  ; set collision test colour to orange, since we drew the walls in orange
  CCOL COL_ORANGE

  ; draw laser in purple
  LD V4, E_LASER_SPRITE_COL_PURPLE
  CALL func_DrawLaser

  ; if laser not collided with walls
  ; then early return
  SE VF, 1
  RET
 
  ; laser collided with a wall
  LD V8, E_LASER_STATE_HIT_WALL					; laser.state = E_LASER_STATE_HIT_WALL

  ; save updated laser state
  LDHI I, data_laser_info-8
  LD [I], V8
  
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoPlayerVsWalls
; Test player against collision walls
;---------------------------------------------------------------------------------
func_DoPlayerVsWalls:

  ; collision walls should have already been drawn in orange 

  ; load player
  LDHI I, data_player_info-9
  LD VC, [I]		
								; V9 = player.state
								; VA = player.timer	
								; VB = player.xpos
								; VC = player.ypos

  ; if (player.state != alive)
  ; then return
  SE V9, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to orange
  CCOL COL_ORANGE

  ; draw player, also in orange
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against walls
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD V9, E_PLAYER_STATE_HIT_WALL

  ; save player state
  LDHI I, data_player_info-9
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; func_DoPlayerVsEnemies
; Test player against collision enemies
;---------------------------------------------------------------------------------
func_DoPlayerVsEnemies:

  ; collision enemies should have already been drawn in green
  ; This will also test against boss if boss collision has been drawn in green 

  ; load player
  LDHI I, data_player_info-9
  LD VC, [I]		
								; V9 = player.state
								; VA = player.timer	
								; VB = player.xpos
								; VC = player.ypos

  ; if (player.state != alive)
  ; then return
  SE V9, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to green
  CCOL COL_GREEN

  ; draw player, in orange
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against enemies
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD V9, E_PLAYER_STATE_HIT_ENEMY

  ; save player state
  LDHI I, data_player_info-9
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
; func_DoPlayerVsBullets
; Test player against collision bullets
;---------------------------------------------------------------------------------
func_DoPlayerVsBullets:

  ; collision bullets should have already been drawn in purple
  ; this will also test collision against laser, MAKE SURE PLAYER AND LASER NEVER OVERLAP

  ; load player
  LDHI I, data_player_info-9
  LD VC, [I]		
								; V9 = player.state
								; VA = player.timer	
								; VB = player.xpos
								; VC = player.ypos

  ; if (player.state != alive)
  ; then return
  SE V9, E_PLAYER_STATE_ALIVE
  RET

  ; set collision test colour to purple
  CCOL COL_PURPLE

  ; draw player, in orange
  LD V4, E_PLAYER_SPRITE_COL_ORANGE
  CALL func_DrawPlayer
  
  ; test for collision of player against bullets
  ; if no collision
  ; then return
  SE VF, 1
  RET

  ; there was a collision
  LD V9, E_PLAYER_STATE_HIT_BULLET

  ; save player state
  LDHI I, data_player_info-9
  LD [I], VC
 
  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoBossVsLaser
;---------------------------------------------------------------------------------
func_DoBossVsLaser:

  ; laser should already have been drawn in purple

  ; load boss info
  LDHI I, data_boss_info-8
  LD VC, [I]
								; V8 = boss.state
								; V9 = boss.health
								; VA = boss.timer
								; VB = boss.xpos
								; VC = boss.ypos
								
  ; set collision test colour to purple, since laser was drawn in purple
  CCOL COL_PURPLE

  LD V4, E_BOSS_SPRITE_COL_GREEN
  CALL func_DrawBossEye

  ; if no collision
  ; then return early
  SE VF, 1
  RET 

  ; load laser info
  LDHI I, data_laser_info-6
  LD V7, [I]	
								; V6 = laser.state
								; V7 = laser.charge

  ; there was a collision between laser and boss
  ; logic is something like this:
  ; if (laser.charge == boss.health)
  ; then laser=dying, boss=dying
  ; else if (laser.charge < boss.health)
  ; then boss.health -= laser.charge, laser=dying
  ; else laser.charge -= boss.charge, enemy=dying

  ; special case for boss: if boss is not 'alive', it takes no damage
  SE V8, E_BOSS_STATE_ALIVE
  JP lbl_boss_vs_laser_no_damage

  ; if laser.charge != boss.health
  ; then goto laser.charge < boss.health test
  SE V7, V9
  JP lbl_boss_vs_laser_less_than

  ; laser.charge == enemy.health, both are dying
  LD V6, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  LD V8, E_BOSS_STATE_KILLED_BY_LASER 				; boss.state = E_BOSS_STATE_KILLED_BY_LASER
   
  ; laser has no more charge, end test
  JP lbl_boss_vs_laser_end					; break
   
lbl_boss_vs_laser_less_than:
  ; if laser.charge > boss.health
  ; then goto laser.charge > boss.health branch
  LD V0, V9
  SUB V0, V7
  SE VF, 1
  JP lbl_boss_vs_laser_greater_than
  
  ; laser.charge < boss.health
  LD VA, 0							; boss.timer = 0
  LD V8, E_BOSS_STATE_DAMAGED_BY_LASER 				; boss.state = E_ENEMY_STATE_DAMAGED_BY_LASER
  SUB V9, V7							; boss.health -= laser.charge
  LD V6, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  
  JP lbl_boss_vs_laser_end					; break

lbl_boss_vs_laser_greater_than:

  SUB V7, V9							; laser.charge -= boss.health
  LD V8, E_BOSS_STATE_KILLED_BY_LASER 				; boss.state = E_BOSS_STATE_KILLED_BY_LASER
  
  JP lbl_boss_vs_laser_end					; break

lbl_boss_vs_laser_no_damage:

  LD V7, 0							; laser.charge = 0
  LD V6, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  
lbl_boss_vs_laser_end:

  ; save laser
  LD [I], V7
  
  ; save boss
  LDHI I, data_boss_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoEnemiesVsMultiCol
;---------------------------------------------------------------------------------
func_DoEnemiesVsMultiCol:

  ; collision walls should have already been drawn in orange
  ; collision player should have also been drawn in orange  
  ; collision laser should have already been drawn in purple

  ; VC is now our enemy loop counter/indexer			; VC = enemy looper
  LD VC, 0	
  
  ; set enemy sprite params
  SPRW ENEMY_WIDTH
  SPRH ENEMY_HEIGHT

lbl_enemies_vs_multicol_loop_start:

  ; load enemy info
  LDHI I, data_enemy_slots-5
  ADD I, VC
  LD VB, [I]
								; V5 = enemy.state
								; V6 = enemy.health
  								; V7 = enemy.timer
  								; V8 = enemy.xpos
								; V9 = enemy.ypos
								; VA = enemy.type
								; VB = enemy.move

  ; if (enemy.state != alive)
  ; then do next enemy
  SE V5, E_ENEMY_STATE_ALIVE
  JP lbl_enemies_vs_multicol_loop_next

  ; else enemy is alive

  ; set collision test colour to orange to test for a collision against walls or player
  CCOL COL_ORANGE
  
  ; draw enemy in green
  LD V4, E_ENEMY_SPRITE_COL_GREEN_B
  CALL func_DrawEnemy

  ; if enemy collided with orange
  ; then jump to orange collision branch
  SNE VF, 1
  JP lbl_enemies_vs_multicol_hit_orange

  ; else no collision
  ; set collision test colour to purple, to test against laser collision
  CCOL COL_PURPLE
 
  ; redraw enemy
  LD V4, E_ENEMY_SPRITE_COL_GREEN_A
  CALL func_DrawEnemy

  ; if enemy collided with purple
  ; then jump to purple collision branch
  SNE VF, 1
  JP lbl_enemies_vs_multicol_hit_purple

  ; else enemy didn't hit anything
  
  JP lbl_enemies_vs_multicol_loop_next				

lbl_enemies_vs_multicol_hit_orange:

  LD V5, E_ENEMY_STATE_HIT_PLAYER_OR_WALL

  ; save enemy
  LDHI I, data_enemy_slots-5
  ADD I, VC
  LD [I], VB

  JP lbl_enemies_vs_multicol_loop_next
    
lbl_enemies_vs_multicol_hit_purple:

  ; load laser info
  LDHI I, data_laser_info-3
  LD V4, [I]
								; V3 = laser.state						
								; V4 = laser.charge
  ; if laser is not alive
  ; the goto next enemy
; TODO - TEST NOT NEEDED?
  SE V3, E_LASER_STATE_ALIVE
  JP lbl_enemies_vs_multicol_loop_next

  ; else laser is alive

  ; logic is something like this:
  ; if (laser.charge == enemy.health)
  ; then laser=dying, enemy=dying
  ; else if (laser.charge < enemy.health)
  ; then enemy.health -= laser.charge, laser=dying
  ; else laser.charge -= enemy.charge, enemy=dying

  ; if laser.charge == enemy.health
  ; then goto laser.charge == enemy.health branch
  SNE V4, V6
  JP lbl_enemies_vs_multicol_laser_equal

  ; else
  ; if laser.charge > enemy.health
  ; then goto laser.charge > enemy.health branch
  LD V0, V6
  SUB V0, V4
  SE VF, 1							; VF = 1 if enemy.health >= laser.charge
  JP lbl_enemies_vs_multicol_laser_greater
  
  ; else laser.charge < enemy.health

  LD V5, E_ENEMY_STATE_DAMAGED_BY_LASER 			; enemy.state = E_ENEMY_STATE_DAMAGED_BY_LASER
  SUB V6, V4							; enemy.health -= laser.charge
  LD V3, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  
  JP lbl_enemies_vs_multicol_laser_end

lbl_enemies_vs_multicol_laser_greater:

  SUB V4, V6							; laser.charge -= enemy.health
  LD V5, E_ENEMY_STATE_KILLED_BY_LASER 				; enemy.state = E_ENEMY_STATE_KILLED_BY_LASER

  JP lbl_enemies_vs_multicol_laser_end

lbl_enemies_vs_multicol_laser_equal:

  LD V3, E_LASER_STATE_HIT_ENEMY				; laser.state = E_LASER_STATE_HIT_ENEMY
  LD V5, E_ENEMY_STATE_KILLED_BY_LASER 				; enemy.state = E_ENEMY_STATE_KILLED_BY_LASER
  
  ; fall through  

lbl_enemies_vs_multicol_laser_end:

  ; save laser info
  LD [I], V4

  ; save enemy
  LDHI I, data_enemy_slots-5
  ADD I, VC
  LD [I], VB

  ; fall through

lbl_enemies_vs_multicol_loop_next:

  SNE VC, E_ENEMY_SLOT_MAX
  RET

  ; if (loop != ENEMY_SLOT_MAX)
  ; then goto start of loop
  ADD VC, SIZEOF_ENEMY
  JP lbl_enemies_vs_multicol_loop_start

lbl_enemies_vs_multicol_end:

  EXIT 								; should never reach here
;---------------------------------------------------------------------------------
  


;---------------------------------------------------------------------------------
; func_DoUpdateBullets
;---------------------------------------------------------------------------------
func_DoUpdateBullets:

  ; VC is bullet loop counter
  LD VC, 0							; VC = loop counter

  SPRW BULLET_WIDTH
  SPRH BULLET_HEIGHT

lbl_do_update_bullets_loop_start:

  ; load bullet info
  LDHI I, data_bullet_slots-7
  ADD I, VC
  LD VB, [I]
								; V7 = bullet.state
  								; V8 = bullet.timer
								; V9 = bullet.xpos
								; VA = bullet.ypos
								; VB = bullet.move

  LDHI I, data_bullet_update_state_switch_lookup
  ADD I, V7
  LD V1, [I]
  LD I, lbl_do_update_bullets_switch_start
  LD [I], V1

lbl_do_update_bullets_switch_start:
  JP lbl_do_update_bullets_switch_start

lbl_do_update_bullets_case_dead:
  JP lbl_do_update_bullets_loop_next

lbl_do_update_bullets_case_hit_something:

  LD V8, 0
  LD V7, E_BULLET_STATE_DYING

  ; fall through

lbl_do_update_bullets_case_dying:
 
  LDHI I, data_bullet_dying_constants-4
  LD V6, [I]
								; V4 = E_BULLET_SPRITE_DYING_0
								; V5 = bullet.const BULLET_DYING_TIMER_INC
								; V6 = bullet.const BULLET_DYING_TIMER_MAX
    
  ADD V4, V8							; V4 += bullet.timer
  CALL func_DrawBullet

  ADD V8, V5							; bullet.timer += bullet.const BULLET_DYING_TIMER_INC

  ; if (bullet.timer == bullet.const BULLET_DYING_TIMER_MAX)
  ; then bullet died
  SNE V8, V6				
  JP lbl_do_update_bullets_now_dead

  ; else bullet is still dying
  
  JP lbl_do_update_bullets_switch_end				; break  

lbl_do_update_bullets_now_dead:

  LD V7, E_BULLET_STATE_DEAD					; bullet.state = E_BULLET_STATE_DEAD

  JP lbl_do_update_bullets_switch_end				; break  

lbl_do_update_bullets_case_alive:

  LDHI I, data_bullet_alive_constants-4
  LD V6, [I]
								; V4 = E_BULLET_SPRITE_ALIVE_0
								; V5 = bullet.const BULLET_ALIVE_X_TO_Y_HALFSTEP
								; V6 = bullet.const BULLET_ALIVE_XPOS_MIN

  LD I, lbl_do_update_bullets_movement_ptr+2
  LD V0, VB
  LD [I], V0

lbl_do_update_bullets_movement_ptr:
  LDHI I, data_bullets_x_movement_aligned

  ADD I, V8
  LD V0, [I]
  ADD V9, V0

; Add 1 to x
;TODO - MERGE THIS INTO BULLET X DELTA TABLES
  ADD V9, 255

; Faster way to get bullet y delta with re-arranged data. But not as fast as it should be! Stupid limited instructions.
; Don't need a full 256 step, so reduce it to 255 or something to remove the second ADD
;TODO - REMOVE HALFSTEP, MAKE 255
  ADD I, V5
  ADD I, V5
  LD V0, [I]
  ADD VA, V0

  CCOL COL_ORANGE
  ADD V4, VE
  CALL func_DrawBullet  

  ; if (bullet hit something orange)
  ; then goto hit something
  SNE VF, 1				
  JP lbl_do_update_bullets_case_hit_something

  ; else if bullet.xpos <= min
  ; then bullet is dead
  SUB V6, V9			
  SNE VF, 1							; VF = 0 if bullet.xpos > bullet.const BULLET_DYING_XPOS_MIN
  JP lbl_do_update_bullets_now_dead				

  ; else bullet is still alive
  
  ADD V8, 1							; bullet.timer++
  
lbl_do_update_bullets_switch_end:

  ; save bullet
  LDHI I, data_bullet_slots-7
  ADD I, VC
  LD [I], VB

lbl_do_update_bullets_loop_next:

  SNE VC, E_BULLET_SLOT_MAX
  RET

  ; if (loop != BULLET_SLOT_MAX)
  ; then goto start of loop
  ADD VC, SIZEOF_BULLET
  JP lbl_do_update_bullets_loop_start

lbl_do_update_bullets_end:

  EXIT								; should never reach here
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateLaser
;---------------------------------------------------------------------------------
func_DoUpdateLaser:

  ; load laser info
  LDHI I, data_laser_info-8
  LD VC, [I]
								; V8 = laser.state
								; V9 = laser.charge
		  						; VA = laser.timer
  								; VB = laser.xpos
								; VC = laser.ypos
  
  ; set up switch
  LDHI I, data_laser_update_state_switch_lookup
  ADD I, V8				
  LD V1, [I]
  LD I, lbl_do_update_laser_switch_start
  LD [I], V1

lbl_do_update_laser_switch_start:
  JP lbl_do_update_laser_switch_start

lbl_do_update_laser_case_dead:

  LDHI I, data_laser_dead_constants-4
  LD V7, [I]
								; V4 = laser.const LASER_DEAD_CHARGE
								; V5 = laser.const LASER_DEAD_OFFSET_X
								; V6 = laser.const LASER_DEAD_OFFSET_Y  
								; V7 = laser.const KEY_FIRE
  ; if (KEY_FIRE != pressed)
  ; then jump to end of switch
  SKP V7							; test KEY_FIRE pressed
  JP lbl_do_update_laser_switch_end				; break

  LDHI I, data_player_info-0
  LD V3, [I]						
								; V0 = player.state
								; V1 = player.timer
								; V2 = player.xpos
								; V3 = player.ypos
  ; if (player != alive)
  ; then jump to end of switch
  SE V0, E_PLAYER_STATE_ALIVE					; cannot fire if player is not alive
  JP lbl_do_update_laser_switch_end				; break
  
  ; laser is now alive
  LD VB, V2
  ADD VB, V5							; laser.xpos = player.xpos + laser.const LASER_DEAD_OFFSET_X

  LD VC, V3
  ADD VC, V6							; laser.ypos = player.ypos + laser.const LASER_DEAD_OFFSET_Y

  LD V8, E_LASER_STATE_ALIVE					; laser.state = E_LASER_STATE_ALIVE
  LD V9, V4							; laser.charge = laser.const LASER_DEAD_CHARGE
  
  JP lbl_do_update_laser_switch_end				; break
    
lbl_do_update_laser_case_hit_enemy:
lbl_do_update_laser_case_hit_wall:

  LD VA, 0							; laser.timer = 0
  LD V8, E_LASER_STATE_DYING					; laser.state = E_LASER_STATE_DYING

  ; fall through to dying

lbl_do_update_laser_case_dying:

  LDHI I, data_laser_dying_constants-4
  LD V7, [I]
								; V4 = E_LASER_SPRITE_DYING_0
								; V5 = empty
								; V6 = laser.const LASER_DYING_TIMER_INC
								; V7 = laser.const LASER_DYING_TIMER_MAX
    
  ADD V4, VA							; V4 += laser.timer
  CALL func_DrawLaser

  ADD VA, V6							; laser.timer += laser.const LASER_DYING_TIMER_INC

  ; if (laser.timer == laser.const LASER_DYING_TIMER_MAX)
  ; then laser died
  SNE VA, V7				
  JP lbl_do_update_laser_now_dead

  ; else laser is still dying
  
  JP lbl_do_update_laser_switch_end				; break  

lbl_do_update_laser_now_dead:

  LD V8, E_LASER_STATE_DEAD					; laser.state = E_LASER_STATE_DEAD

  JP lbl_do_update_laser_switch_end				; break  

lbl_do_update_laser_case_alive:
  
  LDHI I, data_laser_alive_constants-4
  LD V7, [I]
								; V4 = E_LASER_SPRITE_ALIVE_0
								; V5 = empty
								; V6 = laser.const LASER_ALIVE_XPOS_MAX
								; V7 = laser.const LASER_ALIVE_SPEED_X

  ADD V4, VE							; V4 += global.anim
  CALL func_DrawLaser

  ADD VB, V7							; laser.xpos += laser.const LASER_ALIVE_SPEED_X

  ; if (laser.xpos > laser.const LASER_ALIVE_XPOS_MAX)
  ; then skip to laser died
  SUB V6, VB
  SE VF, 1							; VF = 1 if laser.xpos <= laser.const LASER_ALIVE_XPOS_MAX
  JP lbl_do_update_laser_now_dead

  ; else laser is still alive
  
lbl_do_update_laser_switch_end:

  ; save all laser info
  LDHI I, data_laser_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdatePlayerForGameplay
;---------------------------------------------------------------------------------
func_DoUpdatePlayerForGameplay:

  ; load player info
  LDHI I, data_player_info-9
  LD VC, [I]
								; V9 = player.state
 		  						; VA = player.timer
  								; VB = player.xpos
								; VC = player.ypos

  ; set up switch
  LDHI I, data_player_gameplay_update_state_switch_lookup
  ADD I, V9
  LD V1, [I]
  LD I, lbl_do_update_player_gameplay_switch_start
  LD [I], V1

lbl_do_update_player_gameplay_switch_start:
  JP lbl_do_update_player_gameplay_switch_start

lbl_do_update_player_gameplay_case_reviving:

  LDHI I, data_player_gameplay_reviving_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_REVIVING_0
								; V5 = unused
   								; V6 = player.const PLAYER_REVIVING_SPEED_X
								; V7 = player.const PLAYER_REVIVING_TIMER_INC
								; V8 = player.const PLAYER_GAMEPLAY_REVIVING_TIMER_MAX

  ; player reviving uses global.anim counter for animation
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  ADD VA, V7							; player.timer += player.const PLAYER_REVIVNG_TIMER_INC

  ; if (player.timer == player.const PLAYER_GAMEPLAY_REVIVING_TIMER_MAX)
  ; then player is now alive
  SNE VA, V8
  JP lbl_do_update_player_gameplay_now_alive

  ; else player is still reviving
  ADD VB, V6							; player.xpos += player.const PLAYER_REVIVING_SPEED_X

  JP lbl_do_update_player_gameplay_switch_end			; break
  
lbl_do_update_player_gameplay_case_hit_wall:
lbl_do_update_player_gameplay_case_hit_enemy:
lbl_do_update_player_gameplay_case_hit_bullet:

  LD VA, 0							; player.timer = 0
  LD V9, E_PLAYER_STATE_DYING					; player.state = E_PLAYER_STATE_DYING

  ; fall through to case_dying

lbl_do_update_player_gameplay_case_dying:

  LDHI I, data_player_gameplay_dying_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_DYING_0
								; V5 = player.const PLAYER_GAMEPLAY_DYING_XPOS_MIN
								; V6 = player.const PLAYER_GAMEPLAY_DYING_SPEED_X
								; V7 = player.const PLAYER_DYING_TIMER_INC
								; V8 = player.const PLAYER_DYING_TIMER_MAX
 
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  ADD VA, V7							; player.timer += player.const PLAYER_DYING_TIMER_INC

  ; if (player.timer == player.const PLAYER_DYING_TIMER_MAX)
  ; then skip to player has died
  SNE VA, V8
  JP lbl_do_update_player_gameplay_now_dead			

  SUB VB, V6							; player.xpos -= player.const PLAYER_GAMEPLAY_DYING_SPEED_X

  ; if (player.xpos <= player.const PLAYER_GAMEPLAY_DYING_XPOS_MIN)
  ; then skip to player has died
  SUB V5, VB			
  SNE VF, 1							; VF = 0 if player.xpos > player.const PLAYER_GAMEPLAY_DYING_XPOS_MIN
  JP lbl_do_update_player_gameplay_now_dead				

  ; else player is still dying

  JP lbl_do_update_player_gameplay_switch_end 			; break

lbl_do_update_player_gameplay_case_outro:

  LDHI I, data_player_gameplay_outro_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_REVIVING_0
  								; V5 = unused
								; V6 = unused
								; V7 = player.const PLAYER_GAMEPLAY_OUTRO_XPOS_MAX
								; V8 = player.const PLAYER_GAMEPLAY_OUTRO_SPEED_X
 
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer
  
  ADD VB, V8							; player.xpos += player.const PLAYER_GAMEPLAY_OUTRO_SPEED_X

  ; if (player.xpos > player.const PLAYER_GAMEPLAY_OUTRO_XPOS_MAX)
  ; then skip to player outro complete
  SUB V7, VB			
  SNE VF, 0							; VF = 0 if player.xpos > player.const PLAYER_GAMEPLAY_OUTRO_XPOS_MAX
  JP lbl_do_update_player_gameplay_now_outro_complete			

  ; else player is still outro-ing

  JP lbl_do_update_player_gameplay_switch_end			; break

lbl_do_update_player_gameplay_now_outro_complete:

  ; player has finished outro
  LD V9, E_PLAYER_STATE_MODE_NEXT				; player.state = E_PLAYER_STATE_MODE_NEXT	
   
  JP lbl_do_update_player_gameplay_switch_end			; break

lbl_do_update_player_gameplay_now_dead:
  
  ; player has died
  LD V9, E_PLAYER_STATE_MODE_PREV				; player.state = E_PLAYER_STATE_MODE_PREV 

  JP lbl_do_update_player_gameplay_switch_end			; break

lbl_do_update_player_gameplay_case_dead:

  ; empty - do nothing

  JP lbl_do_update_player_gameplay_switch_end			; break

lbl_do_update_player_gameplay_now_alive:

  LD V9, E_PLAYER_STATE_ALIVE					; player.state = E_PLAYER_STATE_ALIVE

  JP lbl_do_update_player_gameplay_switch_end			; break

lbl_do_update_player_gameplay_case_alive:

  ; player alive uses global.anim counter for animation
  LD V4, E_PLAYER_SPRITE_ALIVE_0
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  LDHI I, data_player_alive_constants-0
  LD V8, [I]
								; V0 = player.const PLAYER_ALIVE_XPOS_MIN
								; V1 = player.const PLAYER_ALIVE_XPOS_MAX
								; V2 = player.const PLAYER_ALIVE_SPEED_X
								; V3 = player.const PLAYER_ALIVE_SPEED_Y
								; V4 = E_PLAYER_SPRITE_ALIVE_0
								; V5 = player.const KEY_RIGHT 
								; V6 = player.const KEY_LEFT
								; V7 = player.const KEY_DOWN
								; V8 = player.const KEY_UP

  ; if (KEY_RIGHT != pressed)
  ; then jump to key_left test
  SKP V5							; test KEY_RIGHT pressed
  JP lbl_do_update_player_gameplay_left_key_test

  ; if (player.xpos > player.const PLAYER_ALIVE_XPOS_MAX)
  ; then jump to key_left test
  SUB V1, VB
  SNE VF, 1							; VF = 0 if player.xpos > player.const PLAYER_ALIVE_XPOS_MAX
  ADD VB, V2							; player.xpos += player.const PLAYER_ALIVE_SPEED_X 

lbl_do_update_player_gameplay_left_key_test:
  ; if (KEY_LEFT != pressed)
  ; then jump to key_down test
  SKP V6							; test KEY_LEFT pressed
  JP lbl_do_update_player_gameplay_down_key_test

  ; if (player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN)
  ; then jump to key_down test
  SUB V0, VB						
  SE VF, 1							; VF = 1 if player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN
  SUB VB, V2							; player.xpos -= player.const PLAYER_ALIVE_SPEED_X

lbl_do_update_player_gameplay_down_key_test:
  ; if (KEY_DOWN != pressed)
  ; then jump to key_up test
  SKNP V7
  ADD VC, V3							; player.ypos += player.const PLAYER_SPEED_Y

lbl_do_update_player_gameplay_up_key_test:
  ; if (KEY_UP != pressed)
  ; then jump to switch end
  SKNP V8
  SUB VC, V3							; player.ypos -= player.const PLAYER_SPEED_Y
 
lbl_do_update_player_gameplay_key_test_end:

  SNE VD, GAMEPLAY_GLOBALDATA_MAX
  LD V9, E_PLAYER_STATE_OUTRO

lbl_do_update_player_gameplay_switch_end:

  ; save all player info
  LDHI I, data_player_info-9
  LD [I], VC

  RET
;---------------------------------------------------------------------------------


;---------------------------------------------------------------------------------
; func_DoUpdatePlayerForBossplay
;---------------------------------------------------------------------------------
func_DoUpdatePlayerForBossplay:

  ; load player info
  LDHI I, data_player_info-9
  LD VC, [I]
								; V9 = player.state
 		  						; VA = player.timer
  								; VB = player.xpos
								; VC = player.ypos

  ; set up switch
  LDHI I, data_player_bossplay_update_state_switch_lookup
  ADD I, V9
  LD V1, [I]
  LD I, lbl_do_update_player_bossplay_switch_start
  LD [I], V1

lbl_do_update_player_bossplay_switch_start:
  JP lbl_do_update_player_bossplay_switch_start

lbl_do_update_player_bossplay_case_reviving:

  LDHI I, data_player_bossplay_reviving_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_REVIVING_0
								; V5 = unused
   								; V6 = player.const PLAYER_REVIVING_SPEED_X
								; V7 = player.const PLAYER_REVIVING_TIMER_INC
								; V8 = player.const PLAYER_BOSSPLAY_REVIVING_TIMER_MAX

  ; player reviving uses global.anim counter for animation
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  ADD VA, V7							; player.timer += player.const PLAYER_REVIVNG_TIMER_INC

  ; if (player.timer == player.const PLAYER_BOSSPLAY_REVIVING_TIMER_MAX)
  ; then player is now alive
  SNE VA, V8
  JP lbl_do_update_player_bossplay_now_alive

  ; else player is still reviving
  ADD VB, V6							; player.xpos += player.const PLAYER_REVIVING_SPEED_X

  JP lbl_do_update_player_bossplay_switch_end			; break
  
lbl_do_update_player_bossplay_case_hit_wall:
lbl_do_update_player_bossplay_case_hit_enemy:
lbl_do_update_player_bossplay_case_hit_bullet:

  LD VA, 0							; player.timer = 0
  LD V9, E_PLAYER_STATE_DYING					; player.state = E_PLAYER_STATE_DYING

  ; fall through to case_dying

lbl_do_update_player_bossplay_case_dying:

  LDHI I, data_player_bossplay_dying_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_DYING_0
								; V5 = unused
								; V6 = unused
								; V7 = player.const PLAYER_DYING_TIMER_INC
								; V8 = player.const PLAYER_DYING_TIMER_MAX
 
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  ADD VA, V7							; player.timer += player.const PLAYER_DYING_TIMER_INC

  ; if (player.timer == player.const PLAYER_DYING_TIMER_MAX)
  ; then skip to player has died
  SNE VA, V8
  JP lbl_do_update_player_bossplay_now_dead			

  ; else player is still dying

  JP lbl_do_update_player_bossplay_switch_end 			; break

lbl_do_update_player_bossplay_case_outro:

  LDHI I, data_player_bossplay_outro_constants-4
  LD V8, [I]
								; V4 = E_PLAYER_SPRITE_REVIVING_0
  								; V5 = unused
								; V6 = unused
								; V7 = player.const PLAYER_BOSSPLAY_OUTRO_TIMER_INC
								; V8 = player.const PLAYER_BOSSPLAY_OUTRO_TIMER_MAX
 
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer
  
  ADD VA, V7							; player.timer += player.const PLAYER_BOSSPLAY_OUTRO_TIMER_INC

  ; if (player.timer == player.const PLAYER_BOSSPLAY_OUTRO_TIMER_MAX)
  ; then skip to player has died
  SNE VA, V8
  JP lbl_do_update_player_bossplay_now_outro_complete		

  ; else player is still outro-ing

  JP lbl_do_update_player_bossplay_switch_end			; break

lbl_do_update_player_bossplay_now_outro_complete:

  ; player has finished outro
  LD V9, E_PLAYER_STATE_MODE_NEXT				; player.state = E_PLAYER_STATE_MODE_NEXT
  
  JP lbl_do_update_player_bossplay_switch_end			; break

lbl_do_update_player_bossplay_now_dead:
  
  ; player has died
  LD V9, E_PLAYER_STATE_MODE_PREV				; player.state = E_PLAYER_STATE_MODE_PREV

  JP lbl_do_update_player_bossplay_switch_end			; break

lbl_do_update_player_bossplay_case_disabled:

  ; empty - do nothing

  JP lbl_do_update_player_bossplay_switch_end			; break

lbl_do_update_player_bossplay_now_alive:

  LD V9, E_PLAYER_STATE_ALIVE					; player.state = E_PLAYER_STATE_ALIVE

  JP lbl_do_update_player_bossplay_switch_end			; break

lbl_do_update_player_bossplay_case_alive:

  ; player alive uses global.anim counter for animation
  LD V4, E_PLAYER_SPRITE_ALIVE_0
  ADD V4, VE							; V4 += global.anim
  CALL func_DrawPlayer

  LDHI I, data_player_alive_constants-0
  LD V8, [I]
								; V0 = player.const PLAYER_ALIVE_XPOS_MIN
								; V1 = player.const PLAYER_ALIVE_XPOS_MAX
								; V2 = player.const PLAYER_ALIVE_SPEED_X
								; V3 = player.const PLAYER_ALIVE_SPEED_Y
								; V4 = E_PLAYER_SPRITE_ALIVE_0
								; V5 = player.const KEY_RIGHT 
								; V6 = player.const KEY_LEFT
								; V7 = player.const KEY_DOWN
								; V8 = player.const KEY_UP

  ; if (KEY_RIGHT != pressed)
  ; then jump to key_left test
  SKP V5							; test KEY_RIGHT pressed
  JP lbl_do_update_player_bossplay_left_key_test

  ; if (player.xpos > player.const PLAYER_ALIVE_XPOS_MAX)
  ; then jump to key_left test
  SUB V1, VB
  SNE VF, 1							; VF = 0 if player.xpos > player.const PLAYER_ALIVE_XPOS_MAX
  ADD VB, V2							; player.xpos += player.const PLAYER_ALIVE_SPEED_X 

lbl_do_update_player_bossplay_left_key_test:
  ; if (KEY_LEFT != pressed)
  ; then jump to key_down test
  SKP V6							; test KEY_LEFT pressed
  JP lbl_do_update_player_bossplay_down_key_test

  ; if (player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN)
  ; then jump to key_down test
  SUB V0, VB						
  SE VF, 1							; VF = 1 if player.xpos <= player.const PLAYER_ALIVE_XPOS_MIN
  SUB VB, V2							; player.xpos -= player.const PLAYER_ALIVE_SPEED_X

lbl_do_update_player_bossplay_down_key_test:
  ; if (KEY_DOWN != pressed)
  ; then jump to key_up test
  SKNP V7
  ADD VC, V3							; player.ypos += player.const PLAYER_SPEED_Y

lbl_do_update_player_bossplay_up_key_test:
  ; if (KEY_UP != pressed)
  ; then jump to switch end
  SKNP V8
  SUB VC, V3							; player.ypos -= player.const PLAYER_SPEED_Y
 
lbl_do_update_player_bossplay_key_test_end:

lbl_do_update_player_bossplay_switch_end:

  ; save all player info
  LDHI I, data_player_info-9
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateEnemies
;---------------------------------------------------------------------------------
func_DoUpdateEnemies:

  ; VC is enemy loop counter
  LD VC, 0							; VC = loop counter

  SPRW ENEMY_WIDTH
  SPRH ENEMY_HEIGHT

lbl_do_update_enemies_loop_start:

  ; load enemy info
  LDHI I, data_enemy_slots-5
  ADD I, VC
  LD VB, [I]
								; V5 = enemy.state
								; V6 = enemy.health
  								; V7 = enemy.timer
  								; V8 = enemy.xpos
								; V9 = enemy.ypos
								; VA = enemy.type
								; VB = enemy.move

  ; set up switch
  LDHI I, data_enemy_update_state_switch_lookup
  ADD I, V5
  LD V1, [I]
  LD I, lbl_do_update_enemies_switch_start
  LD [I], V1

lbl_do_update_enemies_switch_start:
  JP lbl_do_update_enemies_switch_start

lbl_do_update_enemies_case_killed_by_laser:
 
  ; load game.score
  LDHI I, data_game_scoreinfo-0			
  LD V3, [I]						
								; V0 = game.score 100s
								; V1 = game.score 10s
								; V2 = game.score 1s
								; V3 = game.score
  ; increment
  ADD V3, GAME_SCORE_INC					; game.score++
  
  ; set BCD
  LD B, V3
  LDHI I, data_game_scoreinfo-0
  LD V2, [I]

  ; save updated game.score
  LD [I], V3

  ; fall through

lbl_do_update_enemies_case_hit_something:

  LD V5, E_ENEMY_STATE_DYING					; enemy.state = E_ENEMY_STATE_DYING
  LD V7, 0							; enemy.timer = 0

 ; fall through to dying

lbl_do_update_enemies_case_dying:

  ; enemy is dying
  LD V4, E_ENEMY_SPRITE_DYING_0
  ADD V4, V7							; V4 += enemy.timer
  CALL func_DrawEnemy

  ; load dying constants
  LDHI I, data_enemy_dying_constants-0
  LD V3, [I]	
								; V0 = enemy.const ENEMY_DYING_XPOS_MIN
								; V1 = enemy.const ENEMY_DYING_SPEED_X
								; V2 = enemy.const ENEMY_DYING_TIMER_INC 
								; V3 = enemy.const ENEMY_DYING_TIMER_MAX 

  ADD V7, V2							; enemy.timer += ENEMY_DYING_TIMER_INC

  ; if (enemy.timer == enemy.const ENEMY_DYING_TIMER_MAX)
  ; then enemy has died
  SNE V7, V3
  JP lbl_do_update_enemies_now_dead				

  SUB V8, V1							; enemy.xpos -= enemy.const ENEMY_DYING_SPEED_X

  ; if (enemy.xpos <= enemy.const ENEMY_DYING_XPOS_MIN)
  ; then skip to died
  SUB V0, V8			
  SNE VF, 1							; VF = 1 if enemy.xpos <= enemy.const ENEMY_DYING_XPOS_MIN
  JP lbl_do_update_enemies_now_dead

  ; else enemy is still dying

  JP lbl_do_update_enemies_switch_end				; break

lbl_do_update_enemies_now_dead:
				
  LD V5, E_ENEMY_STATE_DEAD					; enemy.state = E_ENEMY_STATE_DEAD

  JP lbl_do_update_enemies_switch_end				; break	

lbl_do_update_enemies_case_dead:

  ; empty 

  JP lbl_do_update_enemies_switch_end				; break

lbl_do_update_enemies_case_damaged_by_laser:
 
  ; mark the enemy as damaged shield
  LD V5, E_ENEMY_STATE_DAMAGED_SHIELD_1				; enemy.state = E_ENEMY_STATE_DAMAGED_SHIELD_1
  
  LD V4, E_ENEMY_SPRITE_DAMAGED_0
  JP lbl_do_update_enemies_draw_alive

lbl_do_update_enemies_case_damaged_shield_1:
lbl_do_update_enemies_case_damaged_shield_2:
lbl_do_update_enemies_case_damaged_shield_3:

  ; mark the enemy as damaged shield
  ADD V5, #02							; enemy.state = E_ENEMY_STATE_DAMAGED_SHIELD++
  
  LD V4, E_ENEMY_SPRITE_DAMAGED_0
  JP lbl_do_update_enemies_draw_alive

lbl_do_update_enemies_case_damaged_shield_last:

  ; mark the enemy as alive again
  LD V5, E_ENEMY_STATE_ALIVE					; enemy.state = E_ENEMY_STATE_ALIVE

  ; fall through to alive
  
lbl_do_update_enemies_case_alive:
  
  LD V4, E_ENEMY_SPRITE_ALIVE_0
  
  ; fall through to draw alive

lbl_do_update_enemies_draw_alive:
								; V4 is either E_ENEMY_SPRITE_DAMAGED_0 + global.anim
  ADD V4, VE							; or E_ENEMY_SPRITE_ALIVE_0 + global.anim
  CALL func_DrawEnemy

  LDHI I, data_enemy_alive_constants-0
  LD V3, [I]
								; V0 = enemy.const ENEMY_ALIVE_Y_MOVE_MASK
								; V1 = enemy.const ENEMY_ALIVE_X_MOVE_MASK
								; V2 = enemy.const ENEMY_ALIVE_XPOS_MIN
								; V3 = enemy.const ENEMY_ALIVE_TIMER_MOVE_INC

  AND V1, VB							; V0 = enemy X speed
  SUB V8, V1							; enemy.xpos -= (enemy.move & enemy.const ENEMY_ALIVE_X_MASK)

  ; if (enemy.xpos <= enemy.const ENEMY_ALIVE_XPOS_MIN)
  ; then skip to dying_alive
  SUB V2, V8			
  SNE VF, 1							; VF = 1 if enemy.xpos <= enemy.const ENEMY_ALIVE_XPOS_MIN
  JP lbl_do_update_enemies_now_dead				

  ; else enemy is still alive

  ADD V7, V3							; enemy.timer += enemy.const ENEMY_ALIVE_TIMER_MOVE_INC

  AND V0, VB							; V0 = enemy.move & enemy.const ENEMY_ALIVE_Y_MASK

  LD I, lbl_do_update_enemies_movement_ptr+2
  LD [I], V0
lbl_do_update_enemies_movement_ptr:
  LDHI I, data_enemy_y_movement_aligned

  ADD I, V7
  LD V0, [I]
  ADD V9, V0							; enemy.ypos += movement[enemy.move & enemy.const ENEMY_ALIVE_Y_MASK][enemy.timer]
  
lbl_do_update_enemies_switch_end:

  ; save enemy
  LDHI I, data_enemy_slots-5
  ADD I, VC
  LD [I], VB

lbl_do_update_enemies_loop_next:  
 
  SNE VC, E_ENEMY_SLOT_MAX
  RET

  ; if (loop == ENEMY_SLOT_MAX)
  ; then end test nicely
  ADD VC, SIZEOF_ENEMY
  JP lbl_do_update_enemies_loop_start

lbl_do_update_enemies_end:

  EXIT								; should never reach here
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DoUpdateBoss
;---------------------------------------------------------------------------------
func_DoUpdateBoss:

  ; load boss info
  LDHI I, data_boss_info-8
  LD VC, [I]
								; V8 = boss.state
								; V9 = boss.health
								; VA = boss.timer
  								; VB = boss.xpos
  								; VC = boss.ypos

  ; set up switch
  LDHI I, data_boss_update_switch_lookup
  ADD I, V8
  LD V1, [I]
  LD I, lbl_do_boss_update_switch_start
  LD [I], V1

lbl_do_boss_update_switch_start:
  JP lbl_do_boss_update_switch_start

lbl_do_boss_update_case_damaged_by_laser:

  ; load damaged constants
  LDHI I, data_boss_damaged_constants-4
  LD V7, [I]
               							; V4 = E_BOSS_SPRITE_DAMAGED
             							; V5 = unused
              							; V6 = boss.const BOSS_DAMAGED_TIMER_INC
								; V7 = boss.const BOSS_DAMAGED_TIMER_MAX
 
  CALL func_DrawBossEye

  ADD VA, V6							; boss.timer += BOSS_DAMAGED_TIMER_INC

  ; if (boss.timer == boss.const BOSS_DAMAGED_TIMER_MAX)
  ; then boss is back to alive
  SNE VA, V7
  JP lbl_do_boss_update_now_alive

  ; else boss is still damaged
  
  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_blink:

  ; load blink constants
  LDHI I, data_boss_blink_constants-4
  LD V7, [I]
                						; V4 = E_BOSS_SPRITE_BLINK
               							; V5 = unused
    								; V6 = boss.const BOSS_BLINK_TIMER_INC
								; V7 = boss.const BOSS_BLINK_TIMER_MAX

  CALL func_DrawBossEye

  ADD VA, V6							; boss.timer += BOSS_BLINK_TIMER_INC

  ; if (boss.timer == boss.const BOSS_BLINK_TIMER_MAX)
  ; then boss is back to alive
  SNE VA, V7
  JP lbl_do_boss_update_now_alive

  ; else boss is still blinking

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_killed_by_laser:

  ; boss should start dying
  LD VA, 0							; boss.timer = 0
  LD V8, E_BOSS_STATE_DYING					; boss.state = E_BOSS_STATE_DYING
 
  ; player is now outro-ing
  LDHI I, data_player_info-0
  LD V0, E_PLAYER_STATE_OUTRO					; player.state = E_PLAYER_STATE_OUTRO
  LD V1, 0							; player.timer = 0
  LD [I], V1
   
  ; fall through to dying

lbl_do_boss_update_case_dying:

  ; load dying constants
  LDHI I, data_boss_dying_constants-4
  LD V7, [I]							; V4 = E_BOSS_SPRITE_DYING_0
								; V5 = unused
								; V6 = boss.const BOSS_DYING_TIMER_INC
								; V7 = boss.const BOSS_DYING_TIMER_MAX 

  ADD V4, VE							; V4 += boss.globalanim
  CALL func_DrawBossEye

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_case_dead:

  ; empty

  JP lbl_do_boss_update_switch_end				; break

lbl_do_boss_update_now_alive:

  LD V8, E_BOSS_STATE_ALIVE					; boss.state = E_BOSS_STATE_ALIVE  

  JP lbl_do_boss_update_switch_end  				; break

lbl_do_boss_update_case_alive:

  ; random chance to blink
  RND V0, BOSS_ALIVE_BLINK_CHANCE 
  SE V0, BOSS_ALIVE_BLINK_CHANCE
  JP lbl_do_boss_update_switch_end				; break

  ; do a blink
  LD VA, 0							; boss.timer = 0
  LD V8, E_BOSS_STATE_BLINK					; boss.state = E_BOSS_STATE_BLINK
  
lbl_do_boss_update_switch_end:

  ; save boss
  LDHI I, data_boss_info-8
  LD [I], VC

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBackgroundAndParallax
;---------------------------------------------------------------------------------
func_DrawBackgroundAndParallax:

  SPRW BACKGROUND_WIDTH
  SPRH BACKGROUND_HEIGHT
  LDHI I, data_sprite_background

  LD V0, 0
  DRW V0, V0, 1

  SPRW PARALLAX_WIDTH
  SPRH PARALLAX_HEIGHT

  LDHI I, data_sprite_parallax_A
  LD V6, 8

  SNE VD, GAMEPLAY_GLOBALDATA_MAX
  JP lbl_use_parallax_A

  ; set xpos draw position
  LD V6, 64
  SUB V6, VE
  SHR V6
  SHR V6
  SHR V6							; V6 = (64 - global.anim) / 8

  LD V1, #01
  AND V1, VD
  SE V1, 1
  JP lbl_use_parallax_A

  LDHI I, data_sprite_parallax_B

lbl_use_parallax_A:  

  DRW V6, V0, 1

  RET
;---------------------------------------------------------------------------------


 
;---------------------------------------------------------------------------------
; func_DrawBorder
;---------------------------------------------------------------------------------
func_DrawBorder:

  SPRW BORDER_WIDTH
  SPRH BORDER_HEIGHT

  LDHI I, data_sprite_border
  LD V0, 0
  DRW V0, V0, 1

  LDHI I, data_game_scoreinfo
  LD V7, [I]
								; V0 = game.score 100s
								; V1 = game.score 10s
								; V2 = game.score 1s
								; V3 = game.score
								; V4 = game.const GAME_SCORE_Y_POS
								; V5 = game.const GAME_SCORE_100S_X_POS
								; V6 = game.const GAME_SCORE_10S_X_POS
								; V7 = game.const GAME_SCORE_1S_X_POS

  SPRW NUMBER_WIDTH
  SPRH NUMBER_HEIGHT

  ; draw score 100s
  LD I, lbl_game_border_score_ptr1+2
  LD [I], V0
lbl_game_border_score_ptr1:
  LDHI I, data_number_sprites_aligned
  DRW V9, V8, 1

  ; draw score 10s
  LD I, lbl_game_border_score_ptr2+2
  LD V0, V1
  LD [I], V0
lbl_game_border_score_ptr2:
  LDHI I, data_numbers_sprites_aligned
  DRW VA, V8, 1

  ; draw score 1s
  LD I, lbl_game_border_score_ptr3+2
  LD V0, V2
  LD [I], V0
lbl_game_border_score_ptr3:
  LDHI I, data_numbers_sprites_aligned
  DRW VB, V8, 1

  ; draw lives
  LDHI I, data_game_livesinfo-6
  LD VB, [I]
								; V6 = game.lives
								; V7 = game.const GAME_LIVES_GAMEPLAY_MASK
								; V8 = game.const GAME_LIVES_BOSS_SHIFT
								; V9 = game.const GAME_LIVES_WIN_SHIFT
								; VA = game.const GAME_LIVES_Y_POS
								; VB = game.const GAME_LIVES_X_POS

  LDHI I, data_draw_border_lives_switch_lookup
  ADD I, V6 
  LD V1, [I]
  LD I, lbl_draw_border_lives_switch_start
  LD [I], V1

lbl_draw_border_lives_switch_start:
  JP lbl_draw_border_lives_switch_start

lbl_draw_border_lives_case_lives_3:
lbl_draw_border_lives_case_lives_3_boss:

  LDHI I, data_sprite_number_2
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_lives_2:
lbl_draw_border_lives_case_lives_2_boss:

  LDHI I, data_sprite_number_1
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_lives_1:
lbl_draw_border_lives_case_lives_1_boss:

  LDHI I, data_sprite_number_0
  DRW VB, VA, 1 

  JP lbl_draw_border_lives_switch_end  				; break

lbl_draw_border_lives_case_game_over:
lbl_draw_border_lives_case_start_screen:
lbl_draw_border_lives_case_lives_1_win:
lbl_draw_border_lives_case_lives_2_win:
lbl_draw_border_lives_case_lives_3_win:
lbl_draw_border_lives_case_null:

  ; empty

lbl_draw_border_lives_switch_end:

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawPlayer
; Draws player sprite index V4 at position [VB, VC]
;---------------------------------------------------------------------------------
func_DrawPlayer:
; TODO - INLINE
  SPRW PLAYER_WIDTH
  SPRH PLAYER_HEIGHT

  ; player info must be loaded before func_DrawPlayer is called!
  								; V4 = player sprite
  								; VB = player x-position
  								; VC = player y-position
  LDHI I, data_player_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_player_ptr		
  LD [I], V3		
lbl_draw_player_ptr:
  LDHI I, lbl_draw_player_ptr  

  ; draw player sprite
  DRW VB, VC, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawLaser
; Draws laser sprite index V4 at position [VB, VC]
;---------------------------------------------------------------------------------
func_DrawLaser:
; TODO - INLINE 
  SPRW LASER_WIDTH
  SPRH LASER_HEIGHT

  ; laser info must be loaded before func_DrawLaser is called!
  								; V4 = laser sprite
  								; VB = laser x-position
  								; VC = laser y-position

  LDHI I, data_laser_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_laser_ptr		
  LD [I], V3		
lbl_draw_laser_ptr:
  LDHI I, lbl_draw_laser_ptr  

  ; draw laser sprite
  DRW VB, VC, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBullet
; Draws bullet sprite index V4 at position [V9, VA]
;---------------------------------------------------------------------------------
func_DrawBullet:
;TODO - INLINE func_DrawBullet

  ; bullet info must be loaded before func_DrawBullet is called!
  ; Also make sure SPRW and SPRH have been set correctly!
  								; V4 = bullet sprite
  								; V9 = bullet x-position
  								; VA = bullet y-position
  
  LD I, lbl_draw_bullet_sprite_ptr+2
  LD V0, V4
  LD [I], V0
  
lbl_draw_bullet_sprite_ptr:
  LDHI I, lbl_bullet_sprite_aligned

  ; draw bullet sprite
  DRW V9, VA, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawEnemy
; Draws enemy type VA sprite index V4 at position [V8, V9]
;---------------------------------------------------------------------------------
func_DrawEnemy:
;TODO - INLINE func_DrawEnemy
  
  ; enemy info must be loaded before func_DrawEnemy is called!
  ; Also make sure SPRW and SPRH have been set correctly!
  								; V4 = enemy sprite
  								; V8 = enemy x-position
  								; V9 = enemy y-position
  								; VA = enemy type

  ; use enemy.type VA to set the correct sprite lookup table
  LDHI I, data_enemy_type_lookup
  ADD I, VA
  LD V3, [I]
  LD I, lbl_draw_enemy_sprite_ptr				
  ; and use V4 to draw correct sprite frame
  LD V2, V4
  LD [I], V3

lbl_draw_enemy_sprite_ptr:
  LDHI I, lbl_draw_enemy_sprite_ptr

  ; draw enemy sprite
  DRW V8, V9, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawBossEye
; Draws boss eye sprite index V4 at position [VB, VC]
;---------------------------------------------------------------------------------
func_DrawBossEye:
  
  SPRW BOSS_WIDTH
  SPRH BOSS_HEIGHT

  ; boss info must be loaded before func_DrawBossEye is called!
  								; V4 = boss eye sprite
  								; VB = boss x-position
  								; VC = boss y-position

  LDHI I, data_boss_sprite_lookup
  ADD I, V4

  LD V3, [I]
  LD I, lbl_draw_boss_ptr		
  LD [I], V3		
lbl_draw_boss_ptr:
  LDHI I, lbl_draw_boss_ptr  

  ; draw boss sprite
  DRW VB, VC, 1		

  RET
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawCollisionWalls
; Draws the upper and lower boundary collision walls.
;---------------------------------------------------------------------------------
func_DrawCollisionWalls:

  SPRW WALL_STRIP_WIDTH
  SPRH WALL_STRIP_HEIGHT
  
  LDHI I, data_walls_consts
  LD VB, [I]
								; V8 = WALL_XPOS
								; V9 = GAMEPLAY_GLOBALANIM_MAX
								; VA = WALL_YPOS (Never changes)
								; VB = 12						

  LD VC, VD							; VC = global.data
  ADD VB, VC							; VB = VC + 12
  
  ; set xpos draw position
  SUB V9, VE
  SHR V9
  SHR V9							
  ADD V9, V8							
								; V9 = Wall tile xpos draw position. Initially ((GAMEPLAY_GLOBALANIM_MAX - global.anim) / 4) + WALL_XPOS
								; VA = Wall tile ypos draw position. Never changes.

lbl_draw_collision_walls_loop:

  ; get wall tile index from tile data map
  LDHI I, data_walls_map-5 
  ADD I, VC					
  LD V8, [I]
								; V5 = data_walls_map[VC]
								; V6 = data_walls_map[VC+1]
								; V7 = data_walls_map[VC+2]
								; V8 = data_walls_map[VC+3]
	 
  ; Strip 0
  ; get collision wall sprite from wall collision tile lookup
  LDHI I, data_walls_collision_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_draw_collision_walls_ptr0
  LD [I], V3
lbl_draw_collision_walls_ptr0:
  LDHI I, lbl_draw_collision_walls_ptr0

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ; Strip 1
  ; get collision wall sprite from wall collision tile lookup
  LDHI I, data_walls_collision_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_draw_collision_walls_ptr1
  LD [I], V3
lbl_draw_collision_walls_ptr1:
  LDHI I, lbl_draw_collision_walls_ptr1

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ; Strip 2
  ; get collision wall sprite from wall collision tile lookup
  LDHI I, data_walls_collision_lookup
  ADD I, V7
  LD V3, [I]
  LD I, lbl_draw_collision_walls_ptr2
  LD [I], V3
lbl_draw_collision_walls_ptr2:
  LDHI I, lbl_draw_collision_walls_ptr2

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; if on 4th loop, VC and VB will be equal. We want to early return after 3 strips and save the cost of drawing the 4th.
  SNE VC, VB
  RET

  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ; Strip 3
  ; get collision wall sprite from wall collision tile lookup
  LDHI I, data_walls_collision_lookup
  ADD I, V8
  LD V3, [I]
  LD I, lbl_draw_collision_walls_ptr3
  LD [I], V3
lbl_draw_collision_walls_ptr3:
  LDHI I, lbl_draw_collision_walls_ptr3

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ADD VC, 4							; wall data += 4
  
  ; goto start of loop
  JP lbl_draw_collision_walls_loop

  RET								; should never get here
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; func_DrawRealWalls
; Draws the real upper and lower boundary walls.
;---------------------------------------------------------------------------------
func_DrawRealWalls:

  SPRW WALL_STRIP_WIDTH
  SPRH WALL_STRIP_HEIGHT
  
  LDHI I, data_walls_consts
  LD VB, [I]
								; V8 = WALL_XPOS
								; V9 = GAMEPLAY_GLOBALANIM_MAX
								; VA = WALL_YPOS (Never changes)
								; VB = 12						

  LD VC, VD							; VC = global.data
  ADD VB, VC							; VB = VC + 12
  
  ; set xpos draw position
  SUB V9, VE
  SHR V9
  SHR V9							
  ADD V9, V8							
								; V9 = Wall tile xpos draw position. Initially ((GAMEPLAY_GLOBALANIM_MAX - global.anim) / 4) + WALL_XPOS
								; VA = Wall tile ypos draw position. Never changes.

lbl_draw_real_walls_loop:

  ; get wall tile index from tile data map
  LDHI I, data_walls_map-5 
  ADD I, VC					
  LD V8, [I]
								; V5 = data_walls_map[VC]
								; V6 = data_walls_map[VC+1]
								; V7 = data_walls_map[VC+2]
								; V8 = data_walls_map[VC+3]
	 
  ; Strip 0
  ; get real wall sprite from wall real tile lookup
  LDHI I, data_walls_strip_lookup
  ADD I, V5
  LD V3, [I]
  LD I, lbl_draw_real_walls_ptr0
  LD [I], V3
lbl_draw_real_walls_ptr0:
  LDHI I, lbl_draw_real_walls_ptr0

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ; Strip 1
  ; get real wall sprite from wall real tile lookup
  LDHI I, data_walls_strip_lookup
  ADD I, V6
  LD V3, [I]
  LD I, lbl_draw_real_walls_ptr1
  LD [I], V3
lbl_draw_real_walls_ptr1:
  LDHI I, lbl_draw_real_walls_ptr1

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ; Strip 2
  ; get real wall sprite from wall real tile lookup
  LDHI I, data_walls_strip_lookup
  ADD I, V7
  LD V3, [I]
  LD I, lbl_draw_real_walls_ptr2
  LD [I], V3
lbl_draw_real_walls_ptr2:
  LDHI I, lbl_draw_real_walls_ptr2

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; if on 4th loop, VC and VB will be equal. We want to early return after 3 strips and save the cost of drawing the 4th.
  SNE VC, VB
  RET

  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ; Strip 3
  ; get real wall sprite from wall real tile lookup
  LDHI I, data_walls_strip_lookup
  ADD I, V8
  LD V3, [I]
  LD I, lbl_draw_real_walls_ptr3
  LD [I], V3
lbl_draw_real_walls_ptr3:
  LDHI I, lbl_draw_real_walls_ptr3

  ; draw real wall sprite
  DRW V9, VA, 1
  
  ; offset xpos
  ADD V9, WALL_STRIP_WIDTH					; xpos += WALL_STRIP_WIDTH

  ADD VC, 4							; wall data += 4
  
  ; goto start of loop
  JP lbl_draw_real_walls_loop

  RET								; should never get here
;---------------------------------------------------------------------------------



;---------------------------------------------------------------------------------
; END OF CODE
;---------------------------------------------------------------------------------
lbl_end_code:
  LD I, lbl_end_code
  DA 'All design, code, art and other assets copyright Michael Neve 2012-2013. Secret Brohoof. /)'

;---------------------------------------------------------------------------------
; GAME INFO
;---------------------------------------------------------------------------------
INCLUDE 'gameinfo.src'

;---------------------------------------------------------------------------------
; PLAYER INFO
;---------------------------------------------------------------------------------
INCLUDE 'playerinfo.src'

;---------------------------------------------------------------------------------
; LASER INFO
;---------------------------------------------------------------------------------
INCLUDE 'laserinfo.src'

;---------------------------------------------------------------------------------
; ENEMY INFO
;---------------------------------------------------------------------------------
INCLUDE 'enemyinfo.src'
INCLUDE 'enemy_movement.src'
INCLUDE 'boss.src'

;---------------------------------------------------------------------------------
; BULLET INFO
;---------------------------------------------------------------------------------
INCLUDE 'bulletinfo.src'
INCLUDE 'bullet_movement.src' 

;---------------------------------------------------------------------------------
; WALL INFO
;---------------------------------------------------------------------------------
INCLUDE 'wallinfo.src'

;---------------------------------------------------------------------------------
; GENERIC
;---------------------------------------------------------------------------------

